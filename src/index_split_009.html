<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
    <title>xv6 - DRAFT as of September 3, 2014</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<p class="block_231" id="calibre_pb_15">x GB</p>
	<p class="block_232"></p>
	<p class="block_95">C</p>
	<p class="block_95">PU</p>
	<p class="block_95">Segment</p>
	<p class="block_95">Translation</p>
	<p class="block_95">0</p>
	<p class="block_95">Selector</p>
	<p class="block_95">Offset</p>
	<p class="block_95">Linear</p>
	<p class="block_95">Address</p>
	<p class="block_95">Physical</p>
	<p class="block_95">Address</p>
	<p class="block_95">Logical</p>
	<p class="block_95">Address</p>
	<p class="block_95">Page</p>
	<p class="block_95">Translation</p>
	<p class="block_95">C</p>
	<p class="block_95">PU</p>
	<p class="block_95">Segment</p>
	<p class="block_95">Translation</p>
	<p class="block_95">0</p>
	<p class="block_95">Selector</p>
	<p class="block_95">Offset</p>
	<p class="block_95">Linear</p>
	<p class="block_95">Address</p>
	<p class="block_95">Physical</p>
	<p class="block_95">Address</p>
	<p class="block_95">Logical</p>
	<p class="block_95">Address</p>
	<p class="block_95">Page</p>
	<p class="block_95">Translation</p>
	<p class="block_233"><span class="text_33">RAM </span><span class="text_13">Figure B-1</span><span class="text_12">. The relationship between logical, linear, and physical addresses.</span></p>
	<p class="block_234">Appendix B</p>
	<h1 id="id_Toc460887583" class="block_13">The boot loader</h1>
	<p class="block_235"><span class="text_6"></span><span class="text_7">When an x86 PC boots, it starts executing a program called the BIOS, which is stored in non-volatile memory on the motherboard. The BIOS’s job is to prepare the hardware and then transfer control to the operating system. Specifically, it transfers control to code loaded from the boot sector, the first 512-byte sector of the boot disk. The boot sector contains the boot loader: instructions that load the kernel into memory. The BIOS loads the boot sector at memory address </span><span class="text_8">0x7c00 </span><span class="text_7">and then jumps (sets the processor’s </span><span class="text_8">%ip</span><span class="text_7">) to that address. When the boot loader begins executing, the processor is simulating an Intel 8088, and the loader’s job is to put the processor in a more modern operating mode, to load the xv6 kernel from disk into memory, and then to transfer control to the kernel. The xv6 boot loader comprises two source files, one written in a combination of 16-bit and 32-bit x86 assembly (</span><span class="text_8">bootasm.S</span><span class="text_7">; </span><span class="text_6">(8900)</span><span class="text_7">) and one written in C (</span><span class="text_8">bootmain.c</span><span class="text_7">; </span><span class="text_6">(9000)</span><span class="text_7">).</span></p>
	<h3 class="block_41">Code: Assembly bootstrap</h3>
	<p class="block_18"><span class="text_7">The first instruction in the boot loader is </span><span class="text_8">cli </span><span class="text_6">(8912)</span><span class="text_7">, which disables processor interrupts. Interrupts are a way for hardware devices to invoke operating system functions called interrupt handlers. The BIOS is a tiny operating system, and it might have set up its own interrupt handlers as part of the initializing the hardware. But the BIOS isn’t running anymore—the boot loader is—so it is no longer appropriate or safe to handle interrupts from hardware devices. When xv6 is ready (in Chapter 3), it will re-enable interrupts.</span></p>
	<p class="block_15"><span class="text_2">The processor is in </span><span class="text_3">real mode</span><span class="text_2">, in which it simulates an Intel 8088. In real mode there are eight 16-bit general-purpose registers, but the processor sends 20 bits of address to memory. The segment registers </span><span class="text_3">%cs</span><span class="text_2">, </span><span class="text_3">%ds</span><span class="text_2">, </span><span class="text_3">%es</span><span class="text_2">, and </span><span class="text_3">%ss </span><span class="text_2">provide the additional bits necessary to generate 20-bit memory addresses from 16-bit registers. When a program refers to a memory address, the processor automatically adds 16 times the value of one of the segment registers; these registers are 16 bits wide. Which segment register is usually implicit in the kind of memory reference: instruction fetches use </span><span class="text_3">%cs</span><span class="text_2">, data reads and writes use </span><span class="text_3">%ds</span><span class="text_2">, and stack reads and writes use </span><span class="text_3">%ss</span><span class="text_2">.</span></p>
	<p class="block_15"><span class="text_2">Xv6 pretends that an x86 instruction uses a virtual address for its memory operands, but an x86 instruction actually uses a </span><span class="text_3">logical address </span><span class="text_2">(see Figure B-1). A logical address consists of a segment selector and an offset, and is sometimes written as </span><span class="text_14">segment</span><span class="text_2">:</span><span class="text_14">offset</span><span class="text_2">. More often, the segment is implicit and the program only directly manipulates the offset. The segmentation hardware performs the translation described above to generate a </span><span class="text_3">linear address</span><span class="text_2">. If the paging hardware is enabled (see Chapter 2), it translates linear addresses to physical addresses; otherwise the processor uses linear addresses as physical addresses.</span></p>
	<p class="block_15"><span class="text_2">The boot loader does not enable the paging hardware; the logical addresses that it uses are translated to linear addresses by the segmentation harware, and then used directly as physical addresses. Xv6 configures the segmentation hardware to translate logical to linear addresses without change, so that they are always equal. For historical reasons we have used the term </span><span class="text_3">virtual address </span><span class="text_2">to refer to addresses manipulated by programs; an xv6 virtual address is the same as an x86 logical address, and is equal to the linear address to which the segmentation hardware maps it. Once paging is enabled, the only interesting address mapping in the system will be linear to physical.</span></p>
	<p class="block_18"><span class="text_7">The BIOS does not guarantee anything about the contents of </span><span class="text_8">%ds</span><span class="text_7">, </span><span class="text_8">%es</span><span class="text_7">, </span><span class="text_8">%ss</span><span class="text_7">, so first order of business after disabling interrupts is to set </span><span class="text_8">%ax </span><span class="text_7">to zero and then copy that zero into </span><span class="text_8">%ds</span><span class="text_7">, </span><span class="text_8">%es</span><span class="text_7">, and </span><span class="text_8">%ss </span><span class="text_6">(8915-8918)</span><span class="text_7">.</span></p>
	<p class="block_18"><span class="text_7">A virtual </span><span class="text_15">segment</span><span class="text_7">:</span><span class="text_15">offset </span><span class="text_7">can yield a 21-bit physical address, but the Intel 8088 could only address 20 bits of memory, so it discarded the top bit: </span><span class="text_8">0xffff0</span><span class="text_7">+</span><span class="text_8">0xffff </span><span class="text_7">= </span><span class="text_8">0x10ffef</span><span class="text_7">, but virtual address </span><span class="text_8">0xffff</span><span class="text_7">:</span><span class="text_8">0xffff </span><span class="text_7">on the 8088 referred to physical address </span><span class="text_8">0x0ffef</span><span class="text_7">. Some early software relied on the hardware ignoring the 21st address bit, so when Intel introduced processors with more than 20 bits of physical address, IBM provided a compatibility hack that is a requirement for PC-compatible hardware. If the second bit of the keyboard controller’s output port is low, the 21st physical address bit is always cleared; if high, the 21st bit acts normally. The boot loader must enable the 21st address bit using I/O to the keyboard controller on ports 0x64 and 0x60 </span><span class="text_6">(8920-</span></p>
	<p class="block_236"><span class="text_12">8936)</span><span class="text_4">.</span></p>
	<p class="block_15"><span class="text_2">Real mode’s 16-bit general-purpose and segment registers make it awkward for a program to use more than 65,536 bytes of memory, and impossible to use more than a megabyte. x86 processors since the 80286 have a </span><span class="text_3">protected mode</span><span class="text_2">, which allows physical addresses to have many more bits, and (since the 80386) a ‘‘32-bit’’ mode that causes registers, virtual addresses, and most integer arithmetic to be carried out with 32 bits rather than 16. The xv6 boot sequence enables protected mode and 32-bit mode as follows.</span></p>
	<p class="block_15"><span class="text_2">In protected mode, a segment register is an index into a </span><span class="text_3">segment descriptor table </span><span class="text_2">(see Figure B-2). Each table entry specifies a base physical address, a maximum virtual address called the limit, and permission bits for the segment. These permissions are the protection in protected mode: the kernel can use them to ensure that a program uses only its own memory.</span></p>
	<p class="block_18"><span class="text_7">xv6 makes almost no use of segments; it uses the paging hardware instead, as Chapter 2 describes. The boot loader sets up the segment descriptor table </span><span class="text_8">gdt </span><span class="text_6">(8982-</span></p>
	<p class="block_213"><span class="text_5">8985) </span><span class="text_4">so that all segments have a base address of zero and the maximum possible limit (four gigabytes). The table has a null entry, one entry for executable code, and one en-</span></p>
	<p class="block_237">Logical Address <sub class="calibre18">16</sub><sub class="calibre18"><span class="tab1">       </span>32</sub><sub class="calibre18"><span class="tab1">       </span></sub>Linear Address</p>
	<p class="block_238"></p>
	<p class="block_95"><span class="text_34">S</span></p>
	<p class="block_95"><span class="text_34">e</span></p>
	<p class="block_95"><span class="text_34">le</span></p>
	<p class="block_95"><span class="text_34">c</span></p>
	<p class="block_95"><span class="text_34">tor</span></p>
	<p class="block_95">Offset</p>
	<p class="block_95">Base</p>
	<p class="block_95">Limit</p>
	<p class="block_95">Flags</p>
	<p class="block_95">32</p>
	<p class="block_95">20</p>
	<p class="block_95">12</p>
	<p class="block_95">0</p>
	<p class="block_95">8</p>
	<p class="block_95">16</p>
	<p class="block_95">GDT/LDT</p>
	<p class="block_95"><span class="text_34">S</span></p>
	<p class="block_95"><span class="text_34">e</span></p>
	<p class="block_95"><span class="text_34">le</span></p>
	<p class="block_95"><span class="text_34">c</span></p>
	<p class="block_95"><span class="text_34">tor</span></p>
	<p class="block_95">Offset</p>
	<p class="block_95">Base</p>
	<p class="block_95">Limit</p>
	<p class="block_95">Flags</p>
	<p class="block_95">32</p>
	<p class="block_95">20</p>
	<p class="block_95">12</p>
	<p class="block_95">0</p>
	<p class="block_95">8</p>
	<p class="block_95">16</p>
	<p class="block_95">GDT/LDT</p>
	<p class="block_33"><b class="calibre2">Figure B-2</b>. Segments in protected mode.</p>
	<p class="block_239"><span class="text_4">try to data. The code segment descriptor has a flag set that indicates that the code should run in 32-bit mode </span><span class="text_5">(0660)</span><span class="text_4">. With this setup, when the boot loader enters protected mode, logical addresses map one-to-one to physical addresses.</span></p>
	<p class="block_18"><span class="text_7">The boot loader executes an </span><span class="text_8">lgdt </span><span class="text_7">instruction </span><span class="text_6">(8941) </span><span class="text_7">to load the processor’s global descriptor table (GDT) register with the value </span><span class="text_8">gdtdesc </span><span class="text_6">(8987-8989)</span><span class="text_7">, which points to the table </span><span class="text_8">gdt</span><span class="text_7">.</span></p>
	<p class="block_18"><span class="text_6"></span><span class="text_7">Once it has loaded the GDT register, the boot loader enables protected mode by setting the 1 bit (</span><span class="text_8">CR0_PE</span><span class="text_7">) in register </span><span class="text_8">%cr0 </span><span class="text_6">(8942-8944)</span><span class="text_7">. Enabling protected mode does not immediately change how the processor translates logical to physical addresses; it is only when one loads a new value into a segment register that the processor reads the GDT and changes its internal segmentation settings. One cannot directly modify </span><span class="text_8">%cs</span><span class="text_7">, so instead the code executes an </span><span class="text_8">ljmp </span><span class="text_7">(far jump) instruction </span><span class="text_6">(8953)</span><span class="text_7">, which allows a code segment selector to be specified. The jump continues execution at the next line </span><span class="text_6">(8956) </span><span class="text_7">but in doing so sets </span><span class="text_8">%cs </span><span class="text_7">to refer to the code descriptor entry in </span><span class="text_8">gdt</span><span class="text_7">. That descriptor describes a 32-bit code segment, so the processor switches into 32-bit mode. The boot loader has nursed the processor through an evolution from 8088 through 80286 to 80386.</span></p>
	<p class="block_18"><span class="text_7">The boot loader’s first action in 32-bit mode is to initialize the data segment registers with </span><span class="text_8">SEG_KDATA </span><span class="text_6">(8958-8961)</span><span class="text_7">. Logical address now map directly to physical addresses. The only step left before executing C code is to set up a stack in an unused region of memory. The memory from </span><span class="text_8">0xa0000 </span><span class="text_7">to </span><span class="text_8">0x100000 </span><span class="text_7">is typically littered with device memory regions, and the xv6 kernel expects to be placed at </span><span class="text_8">0x100000. </span><span class="text_7">The boot loader itself is at </span><span class="text_8">0x7c00 </span><span class="text_7">through </span><span class="text_8">0x7d00</span><span class="text_7">. Essentially any other section of memory would be a fine location for the stack. The boot loader chooses </span><span class="text_8">0x7c00 </span><span class="text_7">(known in this file as </span><span class="text_8">$start</span><span class="text_7">) as the top of the stack; the stack will grow down from there, toward </span><span class="text_8">0x0000</span><span class="text_7">, away from the boot loader.</span></p>
	<p class="block_18"><span class="text_7">Finally the boot loader calls the C function </span><span class="text_8">bootmain </span><span class="text_6">(8968)</span><span class="text_7">. </span><span class="text_8">Bootmain</span><span class="text_7">’s job is to load and run the kernel. It only returns if something has gone wrong. In that case, the code sends a few output words on port </span><span class="text_8">0x8a00 </span><span class="text_6">(8970-8976)</span><span class="text_7">. On real hardware, there is no device connected to that port, so this code does nothing. If the boot loader is running inside a PC simulator, port </span><span class="text_8">0x8a00 </span><span class="text_7">is connected to the simulator itself and can transfer control back to the simulator. Simulator or not, the code then executes an infinite loop </span><span class="text_6">(8977-8978)</span><span class="text_7">. A real boot loader might attempt to print an error message first.</span></p>
	<h3 class="block_99">Code: C bootstrap</h3>
	<p class="block_18"><span class="text_7">The C part of the boot loader, </span><span class="text_8">bootmain.c </span><span class="text_6">(9000)</span><span class="text_7">, expects to find a copy of the kernel executable on the disk starting at the second sector. The kernel is an ELF format binary, as we have seen in Chapter 2. To get access to the ELF headers, </span><span class="text_8">bootmain </span><span class="text_7">loads the first 4096 bytes of the ELF binary </span><span class="text_6">(9014)</span><span class="text_7">. It places the in-memory copy at address </span><span class="text_8">0x10000</span><span class="text_7">.</span></p>
	<p class="block_18"><span class="text_7">The next step is a quick check that this probably is an ELF binary, and not an uninitialized disk. </span><span class="text_8">Bootmain </span><span class="text_7">reads the section’s content starting from the disk location </span><span class="text_8">off </span><span class="text_7">bytes after the start of the ELF header, and writes to memory starting at address </span><span class="text_8">paddr</span><span class="text_7">. </span><span class="text_8">Bootmain </span><span class="text_7">calls </span><span class="text_8">readseg </span><span class="text_7">to load data from disk </span><span class="text_6">(9038) </span><span class="text_7">and calls </span><span class="text_8">stosb </span><span class="text_7">to zero the remainder of the segment </span><span class="text_6">(9040)</span><span class="text_7">. </span><span class="text_8">Stosb </span><span class="text_6">(0492) </span><span class="text_7">uses the x86 instruction </span><span class="text_8">rep stosb </span><span class="text_7">to initialize every byte of a block of memory.</span></p>
	<p class="block_15"><span class="text_2">The kernel has been compiled and linked so that it expects to find itself at virtual addresses starting at </span><span class="text_3">0x80100000</span><span class="text_2">. Thus, function call instructions must mention destination addresses that look like </span><span class="text_3">0x801xxxxx</span><span class="text_2">; you can see examples in </span><span class="text_3">kernel.asm</span><span class="text_2">. This address is configured in </span><span class="text_3">kernel.ld</span><span class="text_2">. </span><span class="text_3">0x80100000 </span><span class="text_2">is a relatively high address, towards the end of the 32-bit address space; Chapter 2 explains the reasons for this choice. There may not be any physical memory at such a high address. Once the kernel starts executing, it will set up the paging hardware to map virtual addresses starting at </span><span class="text_3">0x80100000 </span><span class="text_2">to physical addresses starting at </span><span class="text_3">0x00100000</span><span class="text_2">; the kernel assumes that there is physical memory at this lower address. At this point in the boot process, however, paging is not enabled. Instead, </span><span class="text_3">kernel.ld </span><span class="text_2">specifies that the ELF </span><span class="text_3">paddr </span><span class="text_2">start at </span><span class="text_3">0x00100000</span><span class="text_2">, which causes the boot loader to copy the kernel to the low physical addresses to which the paging hardware will eventually point.</span></p>
	<p class="block_240"><span class="text_2">The boot loader’s final step is to call the kernel’s entry point, which is the instruction at which the kernel expects to start executing. For xv6 the entry address is </span><span class="text_3">0x10000c:</span></p>
	<p class="block_38"># objdump -f kernel</p>
	<p class="block_241">kernel: <span class="tab">       </span>file format elf32-i386 architecture: i386, flags 0x00000112: EXEC_P, HAS_SYMS, D_PAGED start address 0x0010000c</p>
	<p class="block_242"><span class="text_7">By convention, the </span><span class="text_8">_start </span><span class="text_7">symbol specifies the ELF entry point, which is defined in the file </span><span class="text_8">entry.S </span><span class="text_6">(1036)</span><span class="text_7">. Since xv6 hasn’t set up virtual memory yet, xv6’s entry point is the physical address of </span><span class="text_8">entry </span><span class="text_6">(1040)</span><span class="text_7">.</span></p>
	<h3 class="block_17">Real world</h3>
	<p class="block_14">The boot loader described in this appendix compiles to around 470 bytes of machine code, depending on the optimizations used when compiling the C code. In order to fit in that small amount of space, the xv6 boot loader makes a major simplifying assumption, that the kernel has been written to the boot disk contiguously starting at sector 1. More commonly, kernels are stored in ordinary file systems, where they may not be contiguous, or are loaded over a network. These complications require the boot loader to be able to drive a variety of disk and network controllers and understand various file systems and network protocols. In other words, the boot loader itself must be a small operating system. Since such complicated boot loaders certainly won’t fit in 512 bytes, most PC operating systems use a two-step boot process. First, a simple boot loader like the one in this appendix loads a full-featured boot-loader from a known disk location, often relying on the less space-constrained BIOS for disk access rather than trying to drive the disk itself. Then the full loader, relieved of the 512-byte limit, can implement the complexity needed to locate, load, and execute the desired kernel. Perhaps a more modern design would have the BIOS directly read a larger boot loader from the disk (and start it in protected and 32-bit mode).</p>
	<p class="block_40">This appendix is written as if the only thing that happens between power on and the execution of the boot loader is that the BIOS loads the boot sector. In fact the BIOS does a huge amount of initialization in order to make the complex hardware of a modern computer look like a traditional standard PC.</p>
	<h3 class="block_90">Exercises</h3>
	<ol class="list_">
	<li class="block_92"><span class="text_2">Due to sector granularity, the call to </span><span class="text_3">readseg </span><span class="text_2">in the text is equivalent to </span><span class="text_3">readseg((uchar*)0x100000, 0xb500, 0x1000)</span><span class="text_2">. In practice, this sloppy behavior turns out not to be a problem Why doesn’t the sloppy readsect cause problems?</span></li>
	<li class="block_130">something about BIOS lasting longer + security problems</li>
	<li class="block_130">Suppose you wanted bootmain() to load the kernel at 0x200000 instead of 0x100000, and you did so by modifying bootmain() to add 0x100000 to the va of each ELF section. Something would go wrong. What?</li>
	<li class="block_243"><span class="text_2">It seems potentially dangerous for the boot loader to copy the ELF header to memory at the arbitrary location </span><span class="text_3">0x10000</span><span class="text_2">. Why doesn’t it call </span><span class="text_3">malloc </span><span class="text_2">to obtain the memory it needs?</span></li>
</ol>
	<p class="block_4"> </p>
	</body></html>
