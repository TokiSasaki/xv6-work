<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
    <title>xv6 - DRAFT as of September 3, 2014</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<p class="block_12" id="calibre_pb_5">Chapter 0</p>
<h1 id="id_Toc460887574" class="block_13">Operating system interfaces</h1>
<p class="paragraph01">The job of an operating system is to share a computer among multiple programs and to provide a more useful set of services than the hardware alone supports. The operating system manages and abstracts the low-level hardware, so that, for example, a word processor need not concern itself with which type of disk hardware is being used. It also multiplexes the hardware, allowing many programs to share the computer and run (or appear to run) at the same time. Finally, operating systems provide controlled ways for programs to interact, so that they can share data or work together.</p>
<p class="paragraph01">An operating system provides services to user programs through an interface. Designing a good interface turns out to be difficult. On the one hand, we would like the interface to be simple and narrow because that makes it easier to get the implementation right. On the other hand, we may be tempted to offer many sophisticated features to applications. The trick in resolving this tension is to design interfaces that rely on a few mechanisms that can be combined to provide much generality.</p>
<p class="paragraph01">This book uses a single operating system as a concrete example to illustrate operating system concepts. That operating system, xv6, provides the basic interfaces introduced by Ken Thompson and Dennis Ritchie's Unix operating system, as well as mimicking Unix's internal design. Unix provides a narrow interface whose mechanisms combine well, offering a surprising degree of generality. This interface has been so successful that modern operating systems—BSD, Linux, Mac OS X, Solaris, and even, to a lesser extent, Microsoft Windows—have Unix-like interfaces. Understanding xv6 is a good start toward understanding any of these systems and many others.</p>
<p class="paragraph01">As shown in Figure 0-1, xv6 takes the traditional form of a <span class="text_3">kernel</span>, a special program that provides services to running programs. Each running program, called a <span class="text_3">process</span>, has memory containing instructions, data, and a stack. The instructions implement the program's computation. The data are the variables on which the computation acts. The stack organizes the program's procedure calls.</p>


<img alt="Image" src="images/figure0-1.png" class="calibre7"/>
<p class="paragraph01"><b>Figure 0-1.</b> A kernel and two user processes.</p>


<p class="paragraph01">When a process needs to invoke a kernel service, it invokes a procedure call in the operating system interface. Such a procedure is called a <span class="text_3">system call</span>. The system call enters the kernel; the kernel performs the service and returns. Thus a process alternates between executing in <span class="text_3">user space</span> and <span class="text_3">kernel space</span>.</p>
<p class="paragraph01">The kernel uses the CPU's hardware protection mechanisms to ensure that each process executing in user space can access only its own memory. The kernel executes with the hardware privileges required to implement these protections; user programs execute without those privileges. When a user program invokes a system call, the hardware raises the privilege level and starts executing a pre-arranged function in the kernel.</p>
<p class="paragraph01">The collection of system calls that a kernel provides is the interface that user programs see. The xv6 kernel provides a subset of the services and system calls that Unix kernels traditionally offer. Figure 0-2 lists all xv6's system calls.</p>


<p class="paragraph01">
<pre><code>
<b>System call                Description</b>
fork()                     Create process
exit()                     Terminate current processo
wait()                     Wait for a child process to exit
kill(pid)                  Terminate process pid
getpid()                   Return current process's id
sleep(n)                   Sleep for n seconds
exec(filename, *argv)      Load a file and execute it
sbrk(n)                    Grow process's memory by n bytes
open(filename, flags)      Open a file; flags indicate read/write
read(fd, buf, n)           Read n byes from an open file into buf
write(fd, buf, n)          Write n bytes to an open file
close(fd)                  Release open file fd
dup(fd)                    Duplicate fd
pipe(p)                    Create a pipe and return fd's in p
chdir(dirname)             Change the current directory
mkdir(dirname)             Create a new directory
mknod(name, major, minor)  Create a device file
fstat(fd)                  Return info about an open file
link(f1, f2)               Create another name (f2) for the file f1
unlink(filename)           Remove a file
</code></pre>
</p>
<p class="paragraph01"><b>Figure 0-2</b>. Xv6 system calls</p>


<p class="paragraph01">The rest of this chapter outlines xv6's services—processes, memory, file descriptors, pipes, and file system—and illustrates them with code snippets and discussions of how the shell uses them. The shell's use of system calls illustrates how carefully they have been designed.</p>
<p class="paragraph01">The shell is an ordinary program that reads commands from the user and executes them, and is the primary user interface to traditional Unix-like systems. The fact that the shell is a user program, not part of the kernel, illustrates the power of the system call interface: there is nothing special about the shell. It also means that the shell is easy to replace; as a result, modern Unix systems have a variety of shells to choose from, each with its own user interface and scripting features. The xv6 shell is a simple implementation of the essence of the Unix Bourne shell. Its implementation can be found at line <span class="text_5">(8350)</span>.</p>


<h3 class="block_17">Processes and memory</h3>
<p class="paragraph01">An xv6 process consists of user-space memory (instructions, data, and stack) and per-process state private to the kernel. Xv6 can <span class="text_3">time-share</span> processes: it transparently switches the available CPUs among the set of processes waiting to execute. When a process is not executing, xv6 saves its CPU registers, restoring them when it next runs the process. The kernel associates a process identifier, or <span class="text_3">pid</span>, with each process.</p>


<p class="paragraph01">A process may create a new process using the <span class="text_3">fork</span> system call. <span class="text_3">Fork</span> creates a new process, called the <span class="text_3">child process</span>, with exactly the same memory contents as the calling process, called the <span class="text_3">parent process</span>. <span class="text_3">Fork</span> returns in both the parent and the child. In the parent, <span class="text_3">fork</span> returns the child's pid; in the child, it returns zero. For example, consider the following program fragment:</p>
<p class="paragraph01">
<pre><code>
int pid = fork();
if(pid &gt; 0){ printf("parent: child=%d\n", pid);
    pid = wait();
    printf("child %d is done\n", pid);
}
else if(pid == 0){
    printf("child: exiting\n");
    exit();
}
else {
    printf("fork error\n");
}
</code></pre>
</p>
<p class="paragraph01">The <span class="text_3">exit</span> system call causes the calling process to stop executing and to release resources such as memory and open files. The <span class="text_3">wait</span> system call returns the pid of an exited child of the current process; if none of the caller's children has exited, <span class="text_3">wait</span> waits for one to do so. In the example, the output lines</p>


<p class="paragraph01">
<pre><code>
parent: child=1234
child: exiting
</code></pre>
</p>


<p class="paragraph01">might come out in either order, depending on whether the parent or child gets to its <span class="text_3">printf</span> call first. After the child exits the parent's <span class="text_3">wait</span> returns, causing the parent to print</p>


<p class="paragraph01">
<pre><code>
parent: child 1234 is done
</code></pre>
</p>


<p class="paragraph01">Note that the parent and child were executing with different memory and different registers: changing a variable in one does not affect the other.</p>
<p class="paragraph01">The <span class="text_3">exec</span> system call replaces the calling process's memory with a new memory image loaded from a file stored in the file system. The file must have a particular format, which specifies which part of the file holds instructions, which part is data, at which instruction to start, etc. xv6 uses the ELF format, which Chapter 2 discusses in more detail. When <span class="text_3">exec</span> succeeds, it does not return to the calling program; instead, the instructions loaded from the file start executing at the entry point declared in the ELF header. <span class="text_3">Exec</span> takes two arguments: the name of the file containing the executable and an array of string arguments. For example:</p>


<p class="paragraph01">
<pre><code>
char *argv[3];
argv[0] = "echo";
argv[1] = "hello";
argv[2] = 0;
exec("/bin/echo", argv);
printf("exec error\n");
</code></pre>
</p>


<p class="paragraph01">This fragment replaces the calling program with an instance of the program <span class="text_3">/bin/echo</span> running with the argument list <span class="text_3">echo hello</span>. Most programs ignore the first argument, which is conventionally the name of the program.</p>

<p class="paragraph01">The xv6 shell uses the above calls to run programs on behalf of users. The main structure of the shell is simple; see <span class="text_3">main</span> <span class="text_5">(8501)</span>. The main loop reads the input on the command line using <span class="text_3">getcmd</span>. Then it calls <span class="text_3">fork</span>, which creates a copy of the shell process. The parent shell calls <span class="text_3">wait</span>, while the child process runs the command. For example, if the user had typed ''<span class="text_3">echo hello</span>'' at the prompt, <span class="text_3">runcmd</span> would have been called with ''<span class="text_3">echo hello</span>'' as the argument. <span class="text_3">runcmd</span> <span class="text_5">(8406)</span> runs the actual command. For ''<span class="text_3">echo hello</span>'', it would call <span class="text_3">exec</span> <span class="text_5">(8426)</span>. If <span class="text_3">exec</span> succeeds then the child will execute instructions from <span class="text_3">echo</span> instead of <span class="text_3">runcmd</span>. At some point <span class="text_3">echo</span> will call <span class="text_3">exit</span>, which will cause the parent to return from <span class="text_3">wait</span> in <span class="text_3">main</span> <span class="text_5">(8501)</span>. You might wonder why <span class="text_3">fork</span> and <span class="text_3">exec</span> are not combined in a single call; we will see later that separate calls for creating a process and loading a program is a clever design.</p>

<p class="paragraph01">Xv6 allocates most user-space memory implicitly: <span class="text_3">fork</span> allocates the memory required for the child's copy of the parent's memory, and <span class="text_3">exec</span> allocates enough memory to hold the executable file. A process that needs more memory at run-time (perhaps for <span class="text_3">malloc</span>) can call <span class="text_3">sbrk(n)</span> to grow its data memory by <span class="text_3">n</span> bytes; <span class="text_3">sbrk</span> returns the location of the new memory.</p>
<p class="paragraph01">Xv6 does not provide a notion of users or of protecting one user from another; in Unix terms, all xv6 processes run as root.</p>


<h3 class="block_41">I/O and File descriptors</h3>
<p class="paragraph01">A <span class="text_3">file descriptor</span> is a small integer representing a kernel-managed object that a process may read from or write to. A process may obtain a file descriptor by opening a file, directory, or device, or by creating a pipe, or by duplicating an existing descriptor. For simplicity we'll often refer to the object a file descriptor refers to as a ''file''; the file descriptor interface abstracts away the differences between files, pipes, and devices, making them all look like streams of bytes.</p>
<p class="paragraph01">Internally, the xv6 kernel uses the file descriptor as an index into a per-process table, so that every process has a private space of file descriptors starting at zero. By convention, a process reads from file descriptor 0 (standard input), writes output to file descriptor 1 (standard output), and writes error messages to file descriptor 2 (standard error). As we will see, the shell exploits the convention to implement I/O redirection and pipelines. The shell ensures that it always has three file descriptors open <span class="text_5">(8507)</span>, which are by default file descriptors for the console.</p>
<p class="paragraph01">The <span class="text_3">read</span> and <span class="text_3">write</span> system calls read bytes from and write bytes to open files named by file descriptors. The call <span class="text_3">read(fd, buf, n)</span> reads at most <span class="text_3">n</span> bytes from the file descriptor <span class="text_3">fd</span>, copies them into <span class="text_3">buf</span>, and returns the number of bytes read. Each file descriptor that refers to a file has an offset associated with it. <span class="text_3">Read</span> reads data from the current file offset and then advances that offset by the number of bytes read: a subsequent <span class="text_3">read</span> will return the bytes following the ones returned by the first <span class="text_3">read</span>. When there are no more bytes to read, <span class="text_3">read</span> returns zero to signal the end of the file.</p>
<p class="paragraph01">The call <span class="text_3">write(fd, buf, n)</span> writes <span class="text_3">n</span> bytes from <span class="text_3">buf</span> to the file descriptor <span class="text_3">fd</span> and returns the number of bytes written. Fewer than <span class="text_3">n</span> bytes are written only when an error occurs. Like <span class="text_3">read</span>, <span class="text_3">write</span> writes data at the current file offset and then advances that offset by the number of bytes written: each <span class="text_3">write</span> picks up where the previous one left off.</p>
<p class="paragraph01">The following program fragment (which forms the essence of <span class="text_3">cat</span>) copies data from its standard input to its standard output. If an error occurs, it writes a message to the standard error.</p>


<p class="paragraph01">
<pre><code>
char buf[512]; 
int n;
for(;;){
    n = read(0, buf, sizeof buf); 
    if(n == 0) break;
    if(n &lt; 0){
        fprintf(2, "read error\n"); 
        exit();
    }
    if(write(1, buf, n) != n){
        fprintf(2, "write error\n"); 
        exit();
    }
}
</code></pre>
</p>


<p class="paragraph01">The important thing to note in the code fragment is that <span class="text_3">cat</span> doesn't know whether it is reading from a file, console, or a pipe. Similarly <span class="text_3">cat</span> doesn't know whether it is printing to a console, a file, or whatever. The use of file descriptors and the convention that file descriptor 0 is input and file descriptor 1 is output allows a simple implementation of <span class="text_3">cat</span>.</p>
<p class="paragraph01">The <span class="text_3">close</span> system call releases a file descriptor, making it free for reuse by a future <span class="text_3">open</span>, <span class="text_3">pipe</span>, or <span class="text_3">dup</span> system call (see below). A newly allocated file descriptor is always the lowest-numbered unused descriptor of the current process.</p>
<p class="paragraph01">File descriptors and <span class="text_3">fork</span> interact to make I/O redirection easy to implement. <span class="text_3">Fork</span> copies the parent's file descriptor table along with its memory, so that the child starts with exactly the same open files as the parent. The system call <span class="text_3">exec</span> replaces the calling process's memory but preserves its file table. This behavior allows the shell to implement I/O redirection by forking, reopening chosen file descriptors, and then execing the new program. Here is a simplified version of the code a shell runs for the command <span class="text_3">cat &lt; input.txt</span>:</p>


<p class="paragraph01">
<pre><code>
char *argv[2];
argv[0] = "cat";
argv[1] = 0;
if(fork() == 0){
    close(0);
    open("input.txt", O_RDONLY);
    exec("cat", argv);
}
</code></pre>
</p>


<p class="paragraph01">After the child closes file descriptor 0, <span class="text_3">open</span> is guaranteed to use that file descriptor for the newly opened <span class="text_3">input.txt</span>: 0 will be the smallest available file descriptor. <span class="text_3">Cat</span> then executes with file descriptor 0 (standard input) referring to <span class="text_3">input.txt</span>.</p>
<p class="paragraph01">The code for I/O redirection in the xv6 shell works in exactly this way <span class="text_5">(8430)</span>. Recall that at this point in the code the shell has already forked the child shell and that <span class="text_3">runcmd</span> will call <span class="text_3">exec</span> to load the new program. Now it should be clear why it is a good idea that <span class="text_3">fork</span> and <span class="text_3">exec</span> are separate calls. This separation allows the shell to fix up the child process before the child runs the intended program.</p>
<p class="paragraph01">Although <span class="text_3">fork</span> copies the file descriptor table, each underlying file offset is shared between parent and child. Consider this example:</p>


<p class="paragraph01">
<pre><code>
if(fork() == 0){
    write(1, "hello ", 6);
    exit();
}
else{
    wait();
    write(1, "world\n", 6);
}
</code></pre>
</p>


<p class="paragraph01">At the end of this fragment, the file attached to file descriptor 1 will contain the data <span class="text_3">hello world</span>. The <span class="text_3">write</span> in the parent (which, thanks to <span class="text_3">wait</span>, runs only after the child is done) picks up where the child's <span class="text_3">write</span> left off. This behavior helps produce sequential output from sequences of shell commands, like <span class="text_3">(echo hello; echo world) &gt; output.txt</span>.</p>
<p class="paragraph01">The <span class="text_3">dup</span> system call duplicates an existing file descriptor, returning a new one that refers to the same underlying I/O object. Both file descriptors share an offset, just as the file descriptors duplicated by <span class="text_3">fork</span> do. This is another way to write <span class="text_3">hello world</span> into a file:</p>


<p class="paragraph01">
<pre><code>
fd = dup(1); write(1, "hello ", 6); write(fd, "world\n", 6);
</code></pre>
</p>



<p class="paragraph01">Two file descriptors share an offset if they were derived from the same original file descriptor by a sequence of <span class="text_3">fork</span> and <span class="text_3">dup</span> calls. Otherwise file descriptors do not share offsets, even if they resulted from <span class="text_3">open</span> calls for the same file. <span class="text_3">Dup</span> allows shells to implement commands like this: <span class="text_3">ls existing-file non-existing-file &gt; tmp1 2&gt;&amp;1</span>. The <span class="text_3">2&gt;&amp;1</span> tells the shell to give the command a file descriptor 2 that is a duplicate of descriptor 1. Both the name of the existing file and the error message for the non-existing file will show up in the file <span class="text_3">tmp1.</span> The xv6 shell doesn't support I/O redirection for the error file descriptor, but now you know how to implement it.</p>
<p class="paragraph01">File descriptors are a powerful abstraction, because they hide the details of what they are connected to: a process writing to file descriptor 1 may be writing to a file, to a device like the console, or to a pipe.</p>


<h3 class="block_56">Pipes</h3>
<p class="paragraph01">A <span class="text_3">pipe</span> is a small kernel buffer exposed to processes as a pair of file descriptors, one for reading and one for writing. Writing data to one end of the pipe makes that data available for reading from the other end of the pipe. Pipes provide a way for processes to communicate.</p>
<p class="paragraph01">The following example code runs the program <span class="text_3">wc</span> with standard input connected to the read end of a pipe.</p>


<p class="paragraph01">
<pre><code>
int p[2];
char *argv[2];
argv[0] = "wc";
argv[1] = 0;
pipe(p);
if(fork() == 0){
    close(0);
    dup(p[0]);
    close(p[0]);
    close(p[1]);
    exec("/bin/wc", argv);
}
else{
    write(p[1], "hello world\n", 12);
    close(p[0]);
    close(p[1]);
}
</code></pre>
</p>


<p class="paragraph01">The program calls <span class="text_3">pipe</span>, which creates a new pipe and records the read and write file descriptors in the array <span class="text_3">p</span>. After <span class="text_3">fork</span>, both parent and child have file descriptors referring to the pipe. The child dups the read end onto file descriptor 0, closes the file descriptors in <span class="text_3">p</span>, and execs <span class="text_3">wc</span>. When <span class="text_3">wc</span> reads from its standard input, it reads from the pipe. The parent writes to the write end of the pipe and then closes both of its file descriptors.</p>
<p class="paragraph01">If no data is available, a <span class="text_3">read</span> on a pipe waits for either data to be written or all file descriptors referring to the write end to be closed; in the latter case, <span class="text_3">read</span> will return 0, just as if the end of a data file had been reached. The fact that <span class="text_3">read</span> blocks until it is impossible for new data to arrive is one reason that it's important for the child to close the write end of the pipe before executing <span class="text_3">wc</span> above: if one of <span class="text_3">wc</span>'s file descriptors referred to the write end of the pipe, <span class="text_3">wc</span> would never see end-of-file.</p>
<p class="paragraph01">The xv6 shell implements pipelines such as <span class="text_3">grep fork sh.c | wc -l</span> in a manner similar to the above code <span class="text_5">(8450)</span>. The child process creates a pipe to connect the left end of the pipeline with the right end. Then it calls <span class="text_3">runcmd</span> for the left end of the pipeline and <span class="text_3">runcmd</span> for the right end, and waits for the left and the right ends to finish, by calling <span class="text_3">wait</span> twice. The right end of the pipeline may be a command that itself includes a pipe (e.g., <span class="text_3">a | b | c</span>), which itself forks two new child processes (one for <span class="text_3">b</span> and one for <span class="text_3">c</span>). Thus, the shell may create a tree of processes. The leaves of this tree are commands and the interior nodes are processes that wait until the left and right children complete. In principle, you could have the interior nodes run the left end of a pipeline, but doing so correctly would complicate the implementation. Pipes may seem no more powerful than temporary files: the pipeline</p>


<p class="paragraph01">
<pre><code>
echo hello world | wc
</code></pre>
</p>


<p class="paragraph01">could be implemented without pipes as</p>


<p class="paragraph01">
<pre><code>
echo hello world &gt;/tmp/xyz; wc &lt;/tmp/xyz
</code></pre>
</p>


<p class="paragraph01">There are at least three key differences between pipes and temporary files. First, pipes automatically clean themselves up; with the file redirection, a shell would have to be careful to remove <span class="text_3">/tmp/xyz</span> when done. Second, pipes can pass arbitrarily long streams of data, while file redirection requires enough free space on disk to store all the data. Third, pipes allow for synchronization: two processes can use a pair of pipes to send messages back and forth to each other, with each <span class="text_3">read</span> blocking its calling process until the other process has sent data with <span class="text_3">write</span>.</p>


<h3 class="block_17">File system</h3>
<p class="paragraph01">The xv6 file system provides data files, which are uninterpreted byte arrays, and directories, which contain named references to data files and other directories. Xv6 implements directories as a special kind of file. The directories form a tree, starting at a special directory called the <span class="text_3">root</span>. A <span class="text_3">path</span> like <span class="text_3">/a/b/c</span> refers to the file or directory named <span class="text_3">c</span> inside the directory named <span class="text_3">b</span> inside the directory named <span class="text_3">a</span> in the root directory <span class="text_3">/</span>. Paths that don't begin with <span class="text_3">/</span> are evaluated relative to the calling process's <span class="text_3">current directory</span>, which can be changed with the <span class="text_3">chdir</span> system call. Both these code fragments open the same file (assuming all the directories involved exist):</p>


<p class="paragraph01">
<pre><code>
chdir("/a");
chdir("b");
open("c", O_RDONLY);
open("/a/b/c", O_RDONLY);
</code></pre>
</p>


<p class="paragraph01">The first fragment changes the process's current directory to <span class="text_3">/a/b</span>; the second neither refers to nor modifies the process's current directory.</p>
<p class="paragraph01">There are multiple system calls to create a new file or directory: <span class="text_3">mkdir</span> creates a new directory, <span class="text_3">open</span> with the <span class="text_3">O_CREATE</span> flag creates a new data file, and <span class="text_3">mknod</span> creates a new device file. This example illustrates all three:</p>


<p class="paragraph01">
mkdir("/dir");
fd = open("/dir/file", O_CREATE|O_WRONLY);
close(fd);
mknod("/console", 1, 1);
</p>


<p class="paragraph01"><span class="text_3">Mknod</span> creates a file in the file system, but the file has no contents. Instead, the file's metadata marks it as a device file and records the major and minor device numbers (the two arguments to <span class="text_3">mknod</span>), which uniquely identify a kernel device. When a process later opens the file, the kernel diverts <span class="text_3">read</span> and <span class="text_3">write</span> system calls to the kernel device implementation instead of passing them to the file system.</p>
<p class="paragraph01"><span class="text_3">fstat</span> retrieves information about the object a file descriptor refers to. It fills in a <span class="text_3">struct stat</span>, defined in <span class="text_3">stat.h</span> as:</p>


<p class="paragraph01">
#define T_DIR  1 // Directory
#define T_FILE 2 // File
#define T_DEV  3 // Device

struct stat {
    short type;  // Type of file
    int dev;     // File system's disk device
    uint ino;    // Inode number
    short nlink; // Number of links to file
    uint size;   // Size of file in bytes
};
</p>


<p class="paragraph01">A file's name is distinct from the file itself; the same underlying file, called an <span class="text_3">inode</span>, can have multiple names, called <span class="text_3">links</span>. The <span class="text_3">link</span> system call creates another file system name referring to the same inode as an existing file. This fragment creates a new file named both <span class="text_3">a</span> and <span class="text_3">b</span>.</p>


<p class="paragraph01">
<pre><code>
open("a", O_CREATE|O_WRONLY);
link("a", "b");
</code></pre>
</p>


<p class="paragraph01">Reading from or writing to <span class="text_3">a</span> is the same as reading from or writing to <span class="text_3">b</span>. Each inode is identified by a unique <span class="text_14">inode number</span>. After the code sequence above, it is possible to determine that <span class="text_3">a</span> and <span class="text_3">b</span> refer to the same underlying contents by inspecting the result of <span class="text_3">fstat</span>: both will return the same inode number (<span class="text_3">ino</span>), and the <span class="text_3">nlink</span> count will be set to 2.</p>
<p class="paragraph01">The <span class="text_3">unlink</span> system call removes a name from the file system. The file's inode and the disk space holding its content are only freed when the file's link count is zero and no file descriptors refer to it. Thus adding</p>


<p class="paragraph01">
<pre><code>
unlink("a");
</code></pre>
</p>


<p class="paragraph01">to the last code sequence leaves the inode and file content accessible as <span class="text_3">b</span>. Furthermore,</p>


<p class="paragraph01">
<pre><code>
fd = open("/tmp/xyz", O_CREATE|O_RDWR);
unlink("/tmp/xyz");
</code></pre>
</p>


<p class="paragraph01">is an idiomatic way to create a temporary inode that will be cleaned up when the process closes <span class="text_3">fd</span> or exits.</p>
<p class="paragraph01">Xv6 commands for file system operations are implemented as user-level programs such as <span class="text_3">mkdir</span>, <span class="text_3">ln</span>, <span class="text_3">rm</span>, etc. This design allows anyone to extend the shell with new user commands. In hind-sight this plan seems obvious, but other systems designed at the time of Unix often built such commands into the shell (and built the shell into the kernel).</p>
<p class="paragraph01">One exception is <span class="text_3">cd</span>, which is built into the shell <span class="text_5">(8516)</span>. <span class="text_3">cd</span> must change the current working directory of the shell itself. If <span class="text_3">cd</span> were run as a regular command, then the shell would fork a child process, the child process would run <span class="text_3">cd</span>, and <span class="text_3">cd</span> would change the <span class="text_15">child</span>'s working directory. The parent's (i.e., the shell's) working directory would not change.</p>

<h3 class="block_17">Real world</h3>
<p class="paragraph01">Unix's combination of the ''standard'' file descriptors, pipes, and convenient shell syntax for operations on them was a major advance in writing general-purpose reusable programs. The idea sparked a whole culture of ''software tools'' that was responsible for much of Unix's power and popularity, and the shell was the first so-called ''scripting language.'' The Unix system call interface persists today in systems like BSD, Linux, and Mac OS X.</p>
<p class="paragraph01">Modern kernels provide many more system calls, and many more kinds of kernel services, than xv6. For the most part, modern Unix-derived operating systems have not followed the early Unix model of exposing devices as special files, like the <span class="text_3">console</span> device file discussed above. The authors of Unix went on to build Plan 9, which applied the ''resources are files'' concept to modern facilities, representing networks, graphics, and other resources as files or file trees.</p>
<p class="paragraph01">The file system abstraction has been a powerful idea, most recently applied to network resources in the form of the World Wide Web. Even so, there are other models for operating system interfaces. Multics, a predecessor of Unix, abstracted file storage in a way that made it look like memory, producing a very different flavor of interface. The complexity of the Multics design had a direct influence on the designers of Unix, who tried to build something simpler.</p>
<p class="paragraph01">This book examines how xv6 implements its Unix-like interface, but the ideas and concepts apply to more than just Unix. Any operating system must multiplex processes onto the underlying hardware, isolate processes from each other, and provide mechanisms for controlled inter-process communication. After studying xv6, you should be able to look at other, more complex operating systems and see the concepts underlying xv6 in those systems as well.</p>


<p class="paragraph01">Chapter 1</p>
    <h1 id="id_Toc460887575" class="block_13">Operating system organization</h1>
<p class="paragraph01">A key requirement for an operating system is to support several activities. For example, using the system call interface described in chapter 0 a process can start new processes using <span class="text_3">fork</span>. The operating system must arrange that these processes can <span class="text_3">time-share</span> the resources of the computer. For example, a process may start more new processes than there are processors in the computer, yet all processes must be able to make some progress. In addition, the operating system must arrange for <span class="text_3">isolation</span> between the processes. That is, if one process has a bug and fails, it shouldn't impact processes that don't have a dependency on the failed process. Complete isolation, however, is too strong, since it should be possible for processes to interact; for example, it is convenient for users to combine processes to perform complex tasks (e.g., by using pipes). Thus, the implementation of an operating system must achieve three requirements: multiplexing, isolation, and interaction.</p>
<p class="paragraph01">This chapter provides an overview of how operating systems are organized to achieve these 3 requirements. It turns out there are many ways to do so, but this text focuses on mainstream designs centered around a <span class="text_3">monolithic kernel</span>, which is used by many Unix operating systems. This chapter illustrates this organization by tracing the first process that is created when xv6 starts running. In doing so, the text provides a glimpse of the implementation of all major abstractions that xv6 provides, how they interact, and how the three requirements of multiplexing, isolation, and interaction are met. Most of xv6 avoids special-casing the first process, and instead reuses code that xv6 must provide for standard operation. Subsequent chapters will explore each abstraction in more detail.</p>
<p class="paragraph01">Xv6 runs on Intel 80386 or later (''x86'') processors on a PC platform, and much of its low-level functionality (for example, its process implementation) is x86-specific. This book assumes the reader has done a bit of machine-level programming on some architecture, and will introduce x86-specific ideas as they come up. Appendix A briefly outlines the PC platform.</p>


<h3 class="block_17">Abstracting physical resources</h3>
<p class="paragraph01">The first question one might ask when encountering an operating system is why have it at all? That is, one could implement the system calls in Figure 0-2 as a library, with which applications link. In this plan, each application could even have its own library, perhaps tailored to its needs. In this plan, the application can directly interact with the hardware resources and use those resources in the best way for the application (e.g., to achieve high performance or predictable performance). Some tiny operating systems for embedded devices or real-time systems are organized in this way.</p>
<p class="paragraph01">The downside of this approach is that applications are free to use the library, which means they can also <i class="calibre3">not </i>use it. If they don't use the operating system library, then the operating system cannot enforce time sharing. It must rely on the application to behave properly and, for example, periodically give up a processor so that another application can run. Such a <i class="calibre3">cooperative </i>time-sharing scheme is maybe OK for a system where all applications trust each other, but doesn't provide strong isolation if applications are mutually distrustful.</p>
<p class="paragraph01">To achieve strong isolation a helpful approach is to disallow applications to have direct access to the hardware resources, but instead to abstract the resources into services. For example, applications interact with a file system only through <span class="text_3">open</span>, <span class="text_3">read</span>, <span class="text_3">write</span>, and <span class="text_3">close</span> system calls, instead of read and writing raw disk sectors. This provides the application with the convenience of pathnames, and it allows the operating system (as the implementor of the interface) to manage the disk.</p>
<p class="paragraph01">Similarly, in Unix applications run as processes using <span class="text_3">fork</span>, allowing the operating system to save and restore registers on behalf of the application when switching between different processes, so that application don't have to be aware of process switching. Furthermore, it allows the operating system to forcefully switch an application out of a processor, if the application, for example, is an end-less loop.</p>
<p class="paragraph01">As another example, Unix processes use <span class="text_3">exec</span> to build up their memory image, instead of directly interacting with physical memory. This allows the operating system to decide where to place a process in memory and move things around if there is a shortage of memory, and provides applications with the convenience of a file system to store their images.</p>
<p class="paragraph01">To support controled interaction between applications, Unix applications can use only file descriptors, instead of to make up some sharing convention of their own (e.g., reserving a piece of physical memory). Unix file descriptors abstract all the sharing details away, hiding from the application if the interaction is happening with the terminal, file system, or pipes, yet allows the operating system to control the interaction. For example, if one application fails, it can shut down the communication channel.</p>
<p class="paragraph01">As you can see, the system call interface in Figure 0-2 is carefully designed to provide programmer convenience but also for the implementation of the interface to enforce strong isolation. The Unix interface is not the only way to abstract resources, but it has proven to be a very good one.</p>


<h3 class="block_17">User mode, kernel mode, and system calls</h3>
<p class="paragraph01">To provide strong isolation between the software that uses system calls and the software that implements the system calls, we need a hard boundary between applications and the operating system. If the application makes a mistake, we don't want the operating system to fail. Instead, the operating system should be able to clean up the application and continue running other applications. This strong isolation means that application shouldn't be able to write over data structures maintained by the operating system, shouldn't be able to overwrite instructions of the operating system, etc.</p>
<p class="paragraph01">To provide for such strong isolation processors provide hardware support.        For example, the x86 processor, like many other processors, has two modes in which the processor executes instructions: <span class="text_3">kernel mode</span> and <span class="text_3">user mode</span>. In kernel mode the processor is allowed to execute <span class="text_3">privileged instructions</span>. For example, read and writing to the disk (or any other I/O device) is a privileged instruction. If an application in user mode attempts to execute a privileged instruction, then the processor doesn't execute the instruction, but switches to kernel mode so that the software in kernel mode can clean up the application, because it did something it shouldn't be doing. Figure 0-1 in Chapter 0 illustrates this organization. Applications can execute only usermode instructions (e.g., adding numbers, etc.) and is said to be running in <span class="text_3">user space</span>, while the software in kernel mode can execute also privileged instructions and is said to be running in <span class="text_3">kernel space</span>. The software running in kernel space (or in kernel mode) is called the <span class="text_3">kernel</span>.</p>
<p class="paragraph01">If a user-mode application must read or write to disk, it must transition to the kernel to do so, because the application itself can not execute I/O instructions. Processors provide a special instruction that switches the processor from user mode to kernel mode and enters the kernel at an entry point specified by the kernel. (The x86 processor provides the <span class="text_3">int</span> instruction for this purpose.) Once the processor has switched to kernel mode, the kernel can then validate the arguments of the system call, decide whether the application is allowed to perform the requested operation, and then deny it or execute it. It is important that the kernel sets the entry point when transition to kernel mode; if the application could decide the kernel entry point, a malicious application could enter the kernel at a point where the validation of arguments etc. is skipped.</p>


<h3 class="block_17">Kernel organization</h3>
<p class="paragraph01">A key design question for an operating system is what part of the operating system should run in kernel mode. A simple answer is that the kernel interface is the system call interface. That is, <span class="text_3">fork</span>, <span class="text_3">exec</span>, <span class="text_3">open</span>, <span class="text_3">close</span>, <span class="text_3">read</span>, <span class="text_3">write</span>, etc. are all kernel calls. This choice means that the complete implementation of the operating system runs in kernel mode. This kernel organization is called a <span class="text_3">monolithic kernel</span>.</p>
<p class="paragraph01">In this organization the complete operating system runs with full hardware privilege. This organization is convenient because the OS designer doesn't have to decide which part of the operating system doesn't need full hardware privilege. Furthermore, it easy for different parts of the operating system to cooperate. For example, an operating system might have a buffer cache that can be shared both by the file system and the virtual memory system.</p>
<p class="paragraph01">A downside of the monolithic organization is that the interfaces between different parts of the operating system are often complex (as we will see in the rest of this text), and therefore it is easy for an operating system developer to make a mistake. In a monolithic kernel, a mistake is fatal, because an error in kernel mode will often result in the kernel to fail. If the kernel fails, the computer stops working, and thus all applications fail too. The computer must reboot to start again.</p>
<p class="paragraph01">To reduce the risk of mistakes in the kernel, OS designers can make the lines of code that run in kernel mode small. Most of the operating system doesn't need access to privileged instructions, and can thus run as ordinary user-level applications, with which applications interact with through messages. This kernel organization is called a <span class="text_3">microkernel</span>.</p>
<p class="paragraph01">Figure 1-1 illustrates this microkernel design. In the figure, the file system runs as a user-level application. Operating systems that services that run as ordinary user programs are called servers. To allow application to interact with the file server, the kernel provides a minimal mechanism to send messages from one user-mode application to another. For example, if an application like the shell wants to read or write a file, it sends a message to the file server and waits for a response.</p>


<img alt="Image" src="images/figure1-1.png" class="calibre7"/>
<p class="paragraph01"><b>Figure 1-1</b>. A mkernel with a file system server</p>


<p class="paragraph01">In a microkernel, the kernel interface consists of a few low-level functions for starting applications, performing I/O, sending messages to applications, etc. This organization allows the kernel to be implemented with a few lines of code, since it doesn't do much, as most functionality of the operating system is implemented by user-level servers.</p>
<p class="paragraph01"><span class="text_5"></span>In the real-world, one can find both monolithic kernels and microkernels. For example, Linux is mostly implemented as a monolithic kernel, although some OS functions run as user-level servers (e.g., the windowing system). Xv6 is implemented as a monolithic kernel, following most Unix operating systems. Thus, in xv6, the kernel interface corresponds to the operating system interface, and the kernel implements the complete operating system. Since xv6 doesn't provide many functions, its kernel is smaller than some microkernels.</p>


<h3 class="block_56">Process overview</h3>
<p class="paragraph01">The unit of isolation in xv6 (as in other Unix operating systems) is a <span class="text_3">process</span>. The process abstraction prevents one process from wrecking or spying on another process' memory, CPU, file descriptors, etc. It also prevents a process from wrecking the kernel itself (i.e., from preventing the kernel to enforce isolation). The kernel must implement the process abstraction with care because a buggy or malicious application may trick the kernel or hardware in doing something bad (e.g., circumventing enforced isolation). The mechanisms used by the kernel to implement processes include user/kernel mode flag, address spaces, and time slicing of threads, which this subsection provides an overview of.</p>
<p class="paragraph01">To be able to enforce isolation, a process is an abstraction that provides the illusion to a program that it has its own abstract machine. A process provides a program with what appears to be a private memory system, or <span class="text_3">address space</span>, which other processes cannot read or write. A process also provides the program with what appears to be its own CPU to execute the program's instructions.</p>
<p class="paragraph01">Xv6 uses page tables (which are implemented by hardware) to give each process its own address space. The x86 page table translates (or ''maps'') a <span class="text_3">virtual address</span> (the address that an x86 instruction manipulates) to a <span class="text_3">physical address</span> (an address that the processor chip sends to main memory).</p>
<p class="paragraph01">Xv6 maintains a separate page table for each process that defines that process's address space. As illustrated in Figure 1-2, an address space includes the process's <span class="text_3">user memory</span> starting at virtual address zero. Instructions come first, followed by global variables, then the stack, and finally a ''heap'' area (for malloc) that the process can expand as needed.</p>


<img alt="Image" src="images/figure1-2.png" class="calibre7"/>
<p class="paragraph01"><b>Figure 1-2</b>. Layout of a virtual address space</p>


<p class="paragraph01"><span class="text_5"></span>Each process's address space maps the kernel's instructions and data as well as the user program's memory. When a process invokes a system call, the system call executes in the kernel mappings of the process's address space. This arrangement exists so that the kernel's system call code can directly refer to user memory. In order to leave room for user memory to grow, xv6's address spaces map the kernel at high addresses, starting at <span class="text_3">0x80100000</span>.</p>

<p class="paragraph01">The xv6 kernel maintains many pieces of state for each process, which it gathers into a <span class="text_3">struct proc</span> <span class="text_5">(2353)</span>. A process's most important pieces of kernel state are its page table, its kernel stack, and its run state. We'll use the notation <span class="text_3">p-&gt;xxx</span> to refer to elements of the <span class="text_3">proc</span> structure.</p>
<p class="paragraph01">Each process has a thread of execution (or <span class="text_3">thread</span> for short) that executes the process's instructions. A thread can be suspended and later resumed. To switch transparently between processes, the kernel suspends the currently running thread and resumes another process's thread. Much of the state of a thread (local variables, function call return addresses) is stored on the thread's stacks. Each process has two stacks: a user stack and a kernel stack (<span class="text_3">p-&gt;kstack</span>). When the process is executing user instructions, only its user stack is in use, and its kernel stack is empty. When the process enters the kernel (for a system call or interrupt), the kernel code executes on the process's kernel stack; while a process is in the kernel, its user stack still contains saved data, but isn't actively used. A process's thread alternates between actively using its user stack and its kernel stack. The kernel stack is separate (and protected from user code) so that the kernel can execute even if a process has wrecked its user stack.</p>
<p class="paragraph01">When a process makes a system call, the processor switches to the kernel stack, raises the hardware privilege level, and starts executing the kernel instructions that implement the system call. When the system call completes, the kernel returns to user space: the hardware lowers its privilege level, switches back to the user stack, and resumes executing user instructions just after the system call instruction. A process's thread can ''block'' in the kernel to wait for I/O, and resume where it left off when the I/O has finished.</p>
<p class="paragraph01"><span class="text_3">p-&gt;state</span> indicates whether the process is allocated, ready to run, running, waiting for I/O, or exiting.</p>
<p class="paragraph01"><span class="text_3">p-&gt;pgdir</span> holds the process's page table, in the format that the x86 hardware expects. xv6 causes the paging hardware to use a process's <span class="text_3">p-&gt;pgdir</span> when executing that process. A process's page table also serves as the record of the addresses of the physical pages allocated to store the process's memory.</p>


<h3 class="block_17">Code: the first address space</h3>
<p class="paragraph01">To make the xv6 organization more concrete, we look how the kernel creates the first address space (for itself), how the kernel creates and starts the first process, and the first system call that that process makes. By tracing these operations we see in detail how xv6 provides strong isolation for processes. The first step in providing strong isolation is setting up the kernel to run in its own address space.</p>
<p class="paragraph01">When a PC powers on, it initializes itself and then loads a <span class="text_3">boot loader</span> from disk into memory and executes it. Appendix B explains the details. Xv6's boot loader loads the xv6 kernel from disk and executes it starting at <span class="text_3">entry</span> <span class="text_5">(1040)</span>. The x86 paging hardware is not enabled when the kernel starts; virtual addresses map directly to physical addresses.</p>
<p class="paragraph01">The boot loader loads the xv6 kernel into memory at physical address <span class="text_3">0x100000</span>. The reason it doesn't load the kernel at <span class="text_3">0x80100000</span>, where the kernel expects to find its instructions and data, is that there may not be any physical memory at such a high address on a small machine. The reason it places the kernel at <span class="text_3">0x100000</span> rather than <span class="text_3">0x0</span> is because the address range <span class="text_3">0xa0000:0x100000</span> contains I/O devices.</p>
<p class="paragraph01">To allow the rest of the kernel to run, <span class="text_3">entry</span> sets up a page table that maps virtual addresses starting at <span class="text_3">0x80000000</span> (called <span class="text_3">KERNBASE</span> <span class="text_5">(0207)</span>) to physical addresses starting at <span class="text_3">0x0</span> (see Figure 1-2). Setting up two ranges of virtual addresses that map to the same physical memory range is a common use of page tables, and we will see more examples like this one.</p>


<img alt="Image" src="images/figure1-3.png" class="calibre7"/>
<p class="paragraph01"><b>Figure 1-3</b>. Layout of a virtual address space</p>


<p class="paragraph01">The entry page table is defined in main.c <span class="text_5">(1311)</span>. We look at the details of page tables in Chapter 2, but the short story is that entry 0 maps virtual addresses</p>
<p class="paragraph01"><span class="text_3">0:0x400000</span> to physical addresses <span class="text_3">0:0x400000</span>. This mapping is required as long as <span class="text_3">entry</span> is executing at low addresses, but will eventually be removed.</p>
<p class="paragraph01">Entry 512 maps virtual addresses <span class="text_3">KERNBASE:KERNBASE+0x400000</span> to physical addresses <span class="text_3">0:0x400000</span>. This entry will be used by the kernel after <span class="text_3">entry</span> has finished; it maps the high virtual addresses at which the kernel expects to find its instructions and data to the low physical addresses where the boot loader loaded them. This mapping restricts the kernel instructions and data to 4 Mbytes.</p>
<p class="paragraph01"><span class="text_5"></span>Returning to <span class="text_3">entry,</span> it loads the physical address of <span class="text_3">entrypgdir</span> into control register <span class="text_3">%cr3.</span> The paging hardware must know the physical address of <span class="text_3">entrypgdir,</span> because it doesn't know how to translate virtual addresses yet; it doesn't have a page table yet. The symbol <span class="text_3">entrypgdir</span> refers to an address in high memory, and the macro <span class="text_3">V2P_WO</span> <span class="text_5">(0220)</span> subtracts <span class="text_3">KERNBASE</span> in order to find the physical address. To enable the paging hardware, xv6 sets the flag <span class="text_3">CR0_PG</span> in the control register <span class="text_3">%cr0.</span></p>
<p class="paragraph01">The processor is still executing instructions at low addresses after paging is enabled, which works since <span class="text_3">entrypgdir</span> maps low addresses. If xv6 had omitted entry 0 from <span class="text_3">entrypgdir,</span> the computer would have crashed when trying to execute the instruction after the one that enabled paging.</p>
<p class="paragraph01">Now <span class="text_3">entry</span> needs to transfer to the kernel's C code, and run it in high memory. First it makes the stack pointer, <span class="text_3">%esp</span>, point to memory to be used as a stack <span class="text_5">(1054)</span>. All symbols have high addresses, including <span class="text_3">stack</span>, so the stack will still be valid even when the low mappings are removed. Finally <span class="text_3">entry</span> jumps to <span class="text_3">main</span>, which is also a high address. The indirect jump is needed because the assembler would otherwise generate a PC-relative direct jump, which would execute the low-memory version of <span class="text_3">main</span>. Main cannot return, since the there's no return PC on the stack. Now the kernel is running in high addresses in the function <span class="text_3">main</span> <span class="text_5">(1217)</span>.</p>


<img alt="Image" src="images/figure1-4.png" class="calibre7"/>
<p class="paragraph01"><b>Figure 1-4</b>. A new kernel stack.</p>


<h3 class="block_17">Code: creating the first process</h3>
<p class="paragraph01">Now the kernel runs within its own address space, we look at how the kernel creates user-level processes and ensures strong isolation between the kernel and user-level processes, and between processes themselves.</p>
<p class="paragraph01">After <span class="text_3">main</span> initializes several devices and subsystems, it creates the first process by calling <span class="text_3">userinit</span> <span class="text_5">(1239)</span>. <span class="text_3">Userinit</span>'s first action is to call <span class="text_3">allocproc</span>. The job of <span class="text_3">allocproc</span> <span class="text_5">(2455)</span> is to allocate a slot (a <span class="text_3">struct proc</span>) in the process table and to initialize the parts of the process's state required for its kernel thread to execute. <span class="text_3">Allocproc</span> is called for each new process, while <span class="text_3">userinit</span> is called only for the very first process.</p>
<p class="paragraph01"><span class="text_5"></span><span class="text_3">Allocproc</span> scans the <span class="text_3">proc</span> table for a slot with state <span class="text_3">UNUSED</span> <span class="text_5">(2461-2463)</span>. When it finds an unused slot, <span class="text_3">allocproc</span> sets the state to <span class="text_3">EMBRYO</span> to mark it as used and gives the process a unique <span class="text_3">pid</span> <span class="text_5">(2451-2469)</span>. Next, it tries to allocate a kernel stack for the process's kernel thread. If the memory allocation fails, <span class="text_3">allocproc</span> changes the state back to <span class="text_3">UNUSED</span> and returns zero to signal failure.</p>

<p class="paragraph01">Now <span class="text_3">allocproc</span> must set up the new process's kernel stack. <span class="text_3">allocproc</span> is written so that it can be used by <span class="text_3">fork</span> as well as when creating the first process. <span class="text_3">allocproc</span> sets up the new process with a specially prepared kernel stack and set of kernel registers that cause it to ''return'' to user space when it first runs. The layout of the prepared kernel stack will be as shown in Figure 1-4. <span class="text_3">allocproc</span> does part of this work by setting up return program counter values that will cause the new process's kernel thread to first execute in <span class="text_3">forkret</span> and then in <span class="text_3">trapret</span> <span class="text_5">(2486-2491)</span>. The kernel thread will start executing with register contents copied from <span class="text_3">p-&gt;context</span>. Thus setting <span class="text_3">p&gt;context-&gt;eip</span> to <span class="text_3">forkret</span> will cause the kernel thread to execute at the start of <span class="text_3">forkret</span> <span class="text_5">(2783)</span>. This function will return to whatever address is at the bottom of the stack. The context switch code <span class="text_5">(2958)</span> sets the stack pointer to point just beyond the end of <span class="text_3">p-&gt;context</span>. <span class="text_3">allocproc</span> places <span class="text_3">p-&gt;context</span> on the stack, and puts a pointer to <span class="text_3">trapret</span> just above it; that is where <span class="text_3">forkret</span> will return. <span class="text_3">trapret</span> restores user registers from values stored at the top of the kernel stack and jumps into the process <span class="text_5">(3277)</span>. This setup is the same for ordinary <span class="text_3">fork</span> and for creating the first process, though in the latter case the process will start executing at user-space location zero rather than at a return from <span class="text_3">fork</span>.</p>
<p class="paragraph01">As we will see in Chapter 3, the way that control transfers from user software to the kernel is via an interrupt mechanism, which is used by system calls, interrupts, and exceptions. Whenever control transfers into the kernel while a process is running, the hardware and xv6 trap entry code save user registers on the process's kernel stack. <span class="text_3">userinit</span> writes values at the top of the new stack that look just like those that would be there if the process had entered the kernel via an interrupt <span class="text_5">(2514-2520)</span>, so that the ordinary code for returning from the kernel back to the process's user code will work. These values are a <span class="text_3">struct trapframe</span> which stores the user registers. Now the new process's kernel stack is completely prepared as shown in Figure 1-4.</p>
<p class="paragraph01">The first process is going to execute a small program (<span class="text_3">initcode.S</span>; <span class="text_5">(8200)</span>). The process needs physical memory in which to store this program, the program needs to be copied to that memory, and the process needs a page table that refers to that memory.</p>
<p class="paragraph01"><span class="text_3">userinit</span> calls <span class="text_3">setupkvm</span> <span class="text_5">(1837)</span> to create a page table for the process with (at first) mappings only for memory that the kernel uses. We will study this function in detail in Chapter 2, but at a high level <span class="text_3">setupkvm</span> and <span class="text_3">userinit</span> create an address space as shown Figure 1-2.</p>
<p class="paragraph01">The initial contents of the first process's memory are the compiled form of <span class="text_3">initcode.S</span>; as part of the kernel build process, the linker embeds that binary in the kernel and defines two special symbols, <span class="text_3">_binary_initcode_start</span> and <span class="text_3">_binary_initcode_size</span>, indicating the location and size of the binary. <span class="text_3">Userinit</span> copies that binary into the new process's memory by calling <span class="text_3">inituvm</span>, which allocates one page of physical memory, maps virtual address zero to that memory, and copies the binary to that page <span class="text_5">(1903)</span>.</p>
<p class="paragraph01">Then <span class="text_3">userinit</span> sets up the trap frame <span class="text_5">(0602)</span> with the initial user mode state: the <span class="text_3">%cs</span> register contains a segment selector for the <span class="text_3">SEG_UCODE</span> segment running at privilege level <span class="text_3">DPL_USER</span> (i.e., user mode not kernel mode), and similarly <span class="text_3">%ds</span>, <span class="text_3">%es</span>, and <span class="text_3">%ss</span> use <span class="text_3">SEG_UDATA</span> with privilege <span class="text_3">DPL_USER</span>. The <span class="text_3">%eflags FL_IF</span> bit is set to allow hardware interrupts; we will reexamine this in Chapter 3.</p>
<p class="paragraph01">The stack pointer <span class="text_3">%esp</span> is set to the process's largest valid virtual address, <span class="text_3">p-&gt;sz</span>. The instruction pointer is set to the entry point for the initcode, address 0.</p>
<p class="paragraph01">The function <span class="text_3">userinit</span> sets <span class="text_3">p-&gt;name</span> to <span class="text_3">initcode</span> mainly for debugging. Setting <span class="text_3">p-&gt;cwd</span> sets the process's current working directory; we will examine <span class="text_3">namei</span> in detail in Chapter 6.</p>
<p class="paragraph01">Once the process is initialized, <span class="text_3">userinit</span> marks it available for scheduling by setting <span class="text_3">p-&gt;state</span> to <span class="text_3">RUNNABLE</span>.</p>


<h3 class="block_17">Code: Running the first process</h3>
<p class="paragraph01">Now that the first process's state is prepared, it is time to run it. After <span class="text_3">main</span> calls <span class="text_3">userinit</span>, <span class="text_3">mpmain</span> calls <span class="text_3">scheduler</span> to start running processes <span class="text_5">(1267)</span>. <span class="text_3">Scheduler</span> <span class="text_5">(2708)</span> looks for a process with <span class="text_3">p-&gt;state</span> set to <span class="text_3">RUNNABLE</span>, and there's only one: <span class="text_3">initproc</span>. It sets the per-cpu variable <span class="text_3">proc</span> to the process it found and calls <span class="text_3">switchuvm</span> to tell the hardware to start using the target process's page table <span class="text_5">(1868)</span>. Changing page tables while executing in the kernel works because <span class="text_3">setupkvm</span> causes all processes' page tables to have identical mappings for kernel code and data. <span class="text_3">switchuvm</span> also sets up a task state segment <span class="text_3">SEG_TSS</span> that instructs the hardware to execute system calls and interrupts on the process's kernel stack. We will re-examine the task state segment in Chapter 3.</p>
<p class="paragraph01"><span class="text_3">scheduler</span> now sets <span class="text_3">p-&gt;state</span> to <span class="text_3">RUNNING</span> and calls <span class="text_3">swtch</span> <span class="text_5">(2958)</span> to perform a context switch to the target process's kernel thread. <span class="text_3">swtch</span> saves the current registers and loads the saved registers of the target kernel thread (<span class="text_3">proc-&gt;context</span>) into the x86 hardware registers, including the stack pointer and instruction pointer. The current context is not a process but rather a special per-cpu scheduler context, so <span class="text_3">scheduler</span> tells <span class="text_3">swtch</span> to save the current hardware registers in per-cpu storage (<span class="text_3">cpu-&gt;scheduler</span>) rather than in any process's kernel thread context. We'll examine <span class="text_3">swtch</span> in more detail in Chapter 5. The final <span class="text_3">ret</span> instruction <span class="text_5">(2977)</span> pops the target process's <span class="text_3">%eip</span> from the stack, finishing the context switch. Now the processor is running on the kernel stack of process <span class="text_3">p</span>.</p>
<p class="paragraph01"><span class="text_3">Allocproc</span> set <span class="text_3">initproc</span>'s <span class="text_3">p-&gt;context-&gt;eip</span> to <span class="text_3">forkret</span>, so the <span class="text_3">ret</span> starts executing <span class="text_3">forkret</span>. On the first invocation (that is this one), <span class="text_3">forkret</span> <span class="text_5">(2783)</span> runs initialization functions that cannot be run from <span class="text_3">main</span> because they must be run in the context of a regular process with its own kernel stack. Then, <span class="text_3">forkret</span> returns. <span class="text_3">Allocproc</span> arranged that the top word on the stack after <span class="text_3">p-&gt;context</span> is popped off would be <span class="text_3">trapret</span>, so now <span class="text_3">trapret</span> begins executing, with <span class="text_3">%esp</span> set to <span class="text_3">p-&gt;tf</span>. <span class="text_3">Trapret</span> <span class="text_5">(3277)</span> uses pop instructions to restore registers from the trap frame <span class="text_5">(0602)</span> just as <span class="text_3">swtch</span> did with the kernel context: <span class="text_3">popal</span> restores the general registers, then the <span class="text_3">popl</span> instructions restore <span class="text_3">%gs</span>, <span class="text_3">%fs</span>, <span class="text_3">%es</span>, and <span class="text_3">%ds</span>. The <span class="text_3">addl</span> skips over the two fields <span class="text_3">trapno</span> and <span class="text_3">errcode</span>. Finally, the <span class="text_3">iret</span> instruction pops <span class="text_3">%cs</span>, <span class="text_3">%eip</span>, <span class="text_3">%flags</span>, <span class="text_3">%esp</span>, and <span class="text_3">%ss</span> from the stack. The contents of the trap frame have been transferred to the CPU state, so the processor continues at the <span class="text_3">%eip</span> specified in the trap frame. For <span class="text_3">initproc</span>, that means virtual address zero, the first instruction of <span class="text_3">initcode.S</span>.</p>
<p class="paragraph01">At this point, <span class="text_3">%eip</span> holds zero and <span class="text_3">%esp</span> holds 4096. These are virtual addresses in the process's address space. The processor's paging hardware translates them into physical addresses. <span class="text_3">allocuvm</span> set up the process's page table so that virtual address zero refers to the physical memory allocated for this process, and set a flag (<span class="text_3">PTE_U</span>) that tells the paging hardware to allow user code to access that memory. The fact that <span class="text_3">userinit</span> <span class="text_5">(2514)</span> set up the low bits of <span class="text_3">%cs</span> to run the process's user code at CPL=3 means that the user code can only use pages with <span class="text_3">PTE_U</span> set, and cannot modify sensitive hardware registers such as <span class="text_3">%cr3</span>. So the process is constrained to using only its own memory.</p>


<h3 class="block_17">The first system call: exec</h3>
<p class="paragraph01">Now we have seen how the kernel provides strong isolation for processes, let's see how a user-level process can enter back into the kernel to ask for services that it cannot perform itself.</p>
<p class="paragraph01">The first action of <span class="text_3">initcode.S</span> is to invoke the <span class="text_3">exec</span> system call. As we saw in Chapter 0, <span class="text_3">exec</span> replaces the memory and registers of the current process with a new program, but it leaves the file descriptors, process id, and parent process unchanged.</p>
<p class="paragraph01"><span class="text_3">Initcode.S</span> <span class="text_5">(8208)</span> begins by pushing three values on the stack—<span class="text_3">$argv</span>, <span class="text_3">$init</span>, and <span class="text_3">$0</span>—and then sets <span class="text_3">%eax</span> to <span class="text_3">SYS_exec</span> and executes <span class="text_3">int T_SYSCALL</span>: it is asking the kernel to run the <span class="text_3">exec</span> system call. If all goes well, <span class="text_3">exec</span> never returns: it starts running the program named by <span class="text_3">$init</span>, which is a pointer to the NUL-terminated string <span class="text_3">/init</span> <span class="text_5">(8221-8223)</span>. If the <span class="text_3">exec</span> fails and does return, initcode loops calling the <span class="text_3">exit</span> system call, which definitely should not return <span class="text_5">(8215-8219)</span>.</p>
<p class="paragraph01">The arguments to the <span class="text_3">exec</span> system call are <span class="text_3">$init</span> and <span class="text_3">$argv</span>. The final zero makes this hand-written system call look like the ordinary system calls, as we will see in Chapter 3. As before, this setup avoids special-casing the first process (in this case, its first system call), and instead reuses code that xv6 must provide for standard operation.</p>
<p class="paragraph01">Chapter 2 will cover the implementation of <span class="text_3">exec</span> in detail, but at a high level it will replace <span class="text_3">initcode</span> with the <span class="text_3">/init</span> binary, loaded out of the file system. Now <span class="text_3">initcode</span> <span class="text_5">(8200)</span> is done, and the process will run <span class="text_3">/init</span> instead. <span class="text_3">Init</span> <span class="text_5">(8310)</span> creates a new console device file if needed and then opens it as file descriptors 0, 1, and 2. Then it loops, starting a console shell, handles orphaned zombies until the shell exits, and repeats. The system is up.</p>


<h3 class="block_17">Real world</h3>
<p class="paragraph01">Most operating systems have adopted the process concept, and most processes look similar to xv6's. A real operating system would find free <span class="text_3">proc</span> structures with an explicit free list in constant time instead of the linear-time search in <span class="text_3">allocproc</span>; xv6 uses the linear scan (the first of many) for simplicity.</p>
<p class="paragraph01">xv6's address space layout has the defect that it cannot make use of more than 2 GB of physical RAM. It's possible to fix this, though the best plan would be to switch to a machine with 64-bit addresses.</p>


<h3 class="block_90">Exercises</h3>
<ol>
    <li>Set a breakpoint at swtch. Single step with gdb's <span class="text_3">stepi</span> through the ret to <span class="text_3">forkret</span>, then use gdb's <span class="text_3">finish</span> to proceed to <span class="text_3">trapret</span>, then <span class="text_3">stepi</span> until you get to <span class="text_3">initcode</span> at virtual address zero.</li>
    <li><span class="text_3">KERNBASE</span> limits the amount of memory a single process can use, which might be irritating on a machine with a full 4 GB of RAM. Would raising <span class="text_3">KERNBASE</span> allow a process to use more memory?</li>
</ol>

</body></html>
