<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
    <title>xv6 - DRAFT as of September 3, 2014</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<ol class="list_">
<li class="block_92">
<span class="text_2">
</span></li>
</ol>
<p class="paragraph01">Chapter 6</p>
	<h1 id="id_Toc460887580" class="block_184">File system</h1>
<p class="paragraph01">The purpose of a file system is to organize and store data. File systems typically support sharing of data among users and applications, as well as <span class="text_3">persistence </span>so that data is still available after a reboot.</p>
<p class="paragraph01">The xv6 file system provides Unix-like files, directories, and pathnames (see Chapter 0), and stores its data on an IDE disk for persistence (see Chapter 3). The file system addresses several challenges:</p>
	<div class="calibre5">
	<div class="block_186">• The file system needs on-disk data structures to represent the tree of named directories and files, to record the identities of the blocks that hold each file's content, and to record which areas of the disk are free.</div>
	<div class="block_187">• The file system must support <span class="text_3">crash recovery. That is, if a crash (e.g., power failure) occurs, the file system must still work correctly after a restart. The risk is that a crash might interrupt a sequence of updates and leave inconsistent on-disk data structures (e.g., a block that is both used in a file and marked free).</span></div>
	<div class="block_188">• Different processes may operate on the file system at the same time, and must coordinate to maintain invariants.</div>
	<div class="block_189">• Accessing a disk is orders of magnitude slower than accessing memory, so the file system must maintain an in-memory cache of popular blocks.</div>
</div>
<p class="paragraph01">The rest of this chapter explains how xv6 addresses these challenges.</p>
	<h3 class="block_17">Overview</h3>
<p class="paragraph01">The xv6 file system implementation is organized in seven layers, shown in Figure 6-1. The disk layer reads and writes blocks on an IDE hard drive. The buffer cache layer caches disk blocks and synchronizes access to them, making sure that only one kernel process at a time can modify the data stored in any particular block. The logging layer allows higher layers to wrap updates to several blocks in a <span class="text_3">transaction</span>, and ensures that the blocks are updated atomically in the face of crashes (i.e., all of them are updated or none). The inode layer provides individual files, each represented as an <span class="text_3">inode </span>with a unique i-number and some blocks holding the file's data. The directory layer implements each directory as a special kind of inode whose content is a sequence of directory entries, each of which contains a file's name and i-number. The pathname layer provides hierarchical path names like <span class="text_3">/usr/rtm/xv6/fs.c</span>, and resolves them with recursive lookup. The file descriptor layer abstracts many Unix resources (e.g., pipes, devices, files, etc.) using the file system interface, simplifying the lives of application programmers.</p>
<p class="paragraph01">The file system must have a plan for where it stores inodes and content blocks on the disk. To do so, xv6 divides the disk into several sections, as shown in Figure 6-2. The file system does not use block 0 (it holds the boot sector). Block 1 is called the</p>
<p class="paragraph01"></p>
<p class="paragraph01">Directory</p>
<p class="paragraph01">Inode</p>
<p class="paragraph01">Logging<span class="text_16"> </span></p>
<p class="paragraph01">Buffer<span class="text_16"> </span>cache</p>
<p class="paragraph01">Directory</p>
<p class="paragraph01">Inode</p>
<p class="paragraph01">Logging<span class="text_16"> </span></p>
<p class="paragraph01">Buffer<span class="text_16"> </span>cache</p>
<p class="paragraph01"><b>Figure 6-1</b>. Layers of the xv6 file system.</p>
<p class="paragraph01"><span class="text_3">superblock</span>; it contains metadata about the file system (the file system size in blocks, the number of data blocks, the number of inodes, and the number of blocks in the log). Blocks starting at 2 hold inodes, with multiple inodes per block. After those come bitmap blocks tracking which data blocks are in use. Most of the remaining blocks are data blocks; each is either marked free in the bitmap block, or holds content for a file or directory. The blocks at the end of the disk hold the logging layer's log.</p>
<p class="paragraph01">The rest of this chapter discusses each layer, starting with the buffer cache. Look out for situations where well-chosen abstractions at lower layers ease the design of higher ones.</p>
	<h3 class="block_17">Buffer cache Layer</h3>
<p class="paragraph01"><span class="text_5"></span>The buffer cache has two jobs: (1) synchronize access to disk blocks to ensure that only one copy of a block is in memory and that only one kernel thread at a time uses that copy; (2) cache popular blocks so that they don't to be re-read from the slow disk. The code is in <span class="text_3">bio.c</span>.</p>
<p class="paragraph01">The main interface exported by the buffer cache consists of <span class="text_3">bread </span>and <span class="text_3">bwrite</span>; the former obtains a <span class="text_3">buf </span>containing a copy of a block which can be read or modified in memory, and the latter writes a modified buffer to the appropriate block on the disk. A kernel thread must release a buffer by calling <span class="text_3">brelse </span>when it is done with it.</p>
<p class="paragraph01">The buffer cache synchronizes access to each block by allowing at most one kernel thread to have a reference to the block's buffer. If one kernel thread has obtained a reference to a buffer but hasn't yet released it, other threads' calls to <span class="text_3">bread </span>for the same block will wait. Higher file system layers rely on the buffer cache's block sychronization to help them maintain invariants.</p>
<p class="paragraph01">The buffer cache has a fixed number of buffers to hold disk blocks, which means that if the file system asks for a block that is not already in the cache, the buffer cache must recycle a buffer currently holding some other block. The buffer cache recycles the least recently used buffer for the new block. The assumption is that the least recently</p>
	<table class="table_1">
		<tbody class="calibre14"><tr class="calibre15">
			<td class="td_3"><p class="paragraph01">boot</p></td>
			<td class="td_4"><p class="paragraph01">super</p></td>
			<td class="td_5"><p class="paragraph01">ino</p></td>
			<td class="td_6"><p class="paragraph01">des</p></td>
			<td class="td_5"><p class="paragraph01">bit </p></td>
			<td class="td_6"><p class="paragraph01">map</p></td>
			<td class="td_7"><p class="paragraph01">data</p></td>
			<td class="td_8"><p class="paragraph01"><span class="calibre17">   ....</span></p></td>
			<td class="td_9"><p class="paragraph01">data </p></td>
			<td class="td_7"><p class="paragraph01"><span class="calibre17">  </span><span class="tab">       </span>l</p></td>
			<td class="td_10"><p class="paragraph01">og</p></td>
		</tr>
	</tbody></table>
<p class="paragraph01"><span class="text_12"></span><span class="text_12">0<span class="tab">       </span>1</span><span class="text_12"><span class="tab">       </span>2</span></p>
<p class="paragraph01"><span class="text_31">Figure 6-2</span><span class="text_29">. Structure of the xv6 file system. The header </span><span class="text_30">fs.h </span><span class="text_32">(3900) </span><span class="text_29">contains constants and data structures describing the exact layout of the file system.</span></p>
<p class="paragraph01">used buffer is the one least likely to be used again soon.</p>
	<h3 class="block_56">Code: Buffer cache</h3>
<p class="paragraph01">The buffer cache is a doubly-linked list of buffers. The function <span class="text_3">binit</span>, called by <span class="text_3">main </span><span class="text_5">(1231)</span>, initializes the list with the <span class="text_3">NBUF </span>buffers in the static array <span class="text_3">buf </span><span class="text_5">(4350-4359)</span>. All other access to the buffer cache refer to the linked list via <span class="text_3">bcache.head</span>, not the <span class="text_3">buf </span>array.</p>
<p class="paragraph01">A buffer has three state bits associated with it. <span class="text_3">B_VALID </span>indicates that the buffer contains a copy of the block. <span class="text_3">B_DIRTY </span>indicates that the buffer content has been modified and needs to be written to the disk. <span class="text_3">B_BUSY </span>indicates that some kernel thread has a reference to this buffer and has not yet released it.</p>
<p class="paragraph01"><span class="text_3">Bread </span><span class="text_5">(4402) </span>calls <span class="text_3">bget </span>to get a buffer for the given sector <span class="text_5">(4406)</span>. If the buffer needs to be read from disk, <span class="text_3">bread </span>calls <span class="text_3">iderw </span>to do that before returning the buffer.</p>
<p class="paragraph01"><span class="text_5"></span><span class="text_3">Bget </span><span class="text_5">(4366) </span>scans the buffer list for a buffer with the given device and sector numbers <span class="text_5">(4373-4384)</span>. If there is such a buffer, and the buffer is not busy, <span class="text_3">bget </span>sets the <span class="text_3">B_BUSY </span>flag and returns <span class="text_5">(4376-4383)</span>. If the buffer is already in use, <span class="text_3">bget </span>sleeps on the buffer to wait for its release. When <span class="text_3">sleep </span>returns, <span class="text_3">bget </span>cannot assume that the buffer is now available. In fact, since <span class="text_3">sleep </span>released and reacquired <span class="text_3">buf_table_lock</span>, there is no guarantee that <span class="text_3">b </span>is still the right buffer: maybe it has been reused for a different disk sector. <span class="text_3">Bget </span>must start over <span class="text_5">(4382)</span>, hoping that the outcome will be different this time.</p>
<p class="paragraph01">If there is no cached buffer for the given sector, <span class="text_3">bget </span>must make one, possibly reusing a buffer that held a different sector. It scans the buffer list a second time, looking for a buffer that is not busy: any such buffer can be used. <span class="text_3">Bget </span>edits the buffer metadata to record the new device and sector number and marks the buffer busy before returning the buffer <span class="text_5">(4393-4395)</span>. Note that the assignment to <span class="text_3">flags </span>not only sets the <span class="text_3">B_BUSY </span>bit but also clears the <span class="text_3">B_VALID </span>and <span class="text_3">B_DIRTY </span>bits, thus ensuring that <span class="text_3">bread </span>will read the block data from disk rather than incorrectly using the buffer's previous contents.</p>
<p class="paragraph01">Because the buffer cache is used for synchronization, it is important that there is only ever one buffer for a particular disk sector. The assignments <span class="text_5">(4391-4393) </span>are only safe because <span class="text_3">bget</span>'s first loop determined that no buffer already existed for that sector, and <span class="text_3">bget </span>has not given up <span class="text_3">buf_table_lock </span>since then.</p>
<p class="paragraph01">If all the buffers are busy, something has gone wrong: <span class="text_3">bget </span>panics. A more graceful response might be to sleep until a buffer became free, though there would then be a possibility of deadlock.</p>
<p class="paragraph01">Once <span class="text_3">bread </span>has returned a buffer to its caller, the caller has exclusive use of the buffer and can read or write the data bytes. If the caller does write to the data, it must call <span class="text_3">bwrite </span>to write the changed data to disk before releasing the buffer. <span class="text_3">Bwrite </span><span class="text_5">(4414) </span>sets the <span class="text_3">B_DIRTY </span>flag and calls <span class="text_3">iderw </span>to write the buffer to disk.</p>
<p class="paragraph01">When the caller is done with a buffer, it must call <span class="text_3">brelse </span>to release it. (The name <span class="text_3">brelse</span>, a shortening of b-release, is cryptic but worth learning: it originated in Unix and is used in BSD, Linux, and Solaris too.) <span class="text_3">Brelse </span><span class="text_5">(4425) </span>moves the buffer to the front of the linked list <span class="text_5">(4432-4437)</span>, clears the <span class="text_3">B_BUSY </span>bit, and wakes any processes sleeping on the buffer. Moving the buffer causes the list to be ordered by how recently the buffers were used (meaning released): the first buffer in the list is the most recently used, and the last is the least recently used. The two loops in <span class="text_3">bget </span>take advantage of this: the scan for an existing buffer must process the entire list in the worst case, but checking the most recently used buffers first (starting at <span class="text_3">bcache.head </span>and following <span class="text_3">next </span>pointers) will reduce scan time when there is good locality of reference. The scan to pick a buffer to reuse picks the least recently used buffer by scanning backward (following <span class="text_3">prev </span>pointers).</p>
	<h3 class="block_17">Logging layer</h3>
<p class="paragraph01">One of the most interesting problems in file system design is crash recovery. The problem arises because many file system operations involve multiple writes to the disk, and a crash after a subset of the writes may leave the on-disk file system in an inconsistent state. For example, depending on the order of the disk writes, a crash during file deletion may either leave a directory entry pointing to a free inode, or it may leave an allocated but unreferenced inode. The latter is relatively benign, but a directory entry that refers to a freed inode is likely to cause serious problems after a reboot.</p>
<p class="paragraph01">Xv6 solves the problem of crashes during file system operations with a simple version of logging. An xv6 system call does not directly write the on-disk file system data structures. Instead, it places a description of all the disk writes it wishes to make in a <span class="text_3">log </span>on the disk. Once the system call has logged all of its writes, it writes a special <span class="text_3">commit </span>record to the disk indicating that the log contains a complete operation. At that point the system call copies the writes to the on-disk file system data structures. After those writes have completed, the system call erases the log on disk.</p>
<p class="paragraph01">If the system should crash and reboot, the file system code recovers from the crash as follows, before running any processes. If the log is marked as containing a complete operation, then the recovery code copies the writes to where they belong in the on-disk file system. If the log is not marked as containing a complete operation, the recovery code ignores the log. The recovery code finishes by erasing the log.</p>
<p class="paragraph01">Why does xv6's log solve the problem of crashes during file system operations? If the crash occurs before the operation commits, then the log on disk will not be marked as complete, the recovery code will ignore it, and the state of the disk will be as if the operation had not even started. If the crash occurs after the operation commits, then recovery will replay all of the operation's writes, perhaps repeating them if the operation had started to write them to the on-disk data structure. In either case, the log makes operations atomic with respect to crashes: after recovery, either all of the operation's writes appear on the disk, or none of them appear.</p>
	<h3 class="block_17">Log design</h3>
<p class="paragraph01">The log resides at a known fixed location at the end of the disk. It consists of a header block followed by a sequence of updated block copies (''logged blocks''). The header block contains an array of sector numbers, one for each of the logged blocks. The header block also contains the count of logged blocks. Xv6 writes the header block when a transaction commits, but not before, and sets the count to zero after copying the logged blocks to the file system. Thus a crash midway through a transaction will result in a count of zero in the log's header block; a crash after a commit will result in a non-zero count.</p>
<p class="paragraph01">Each system call's code indicates the start and end of the sequence of writes that must be atomic. For efficiency, and to allow a degree of concurrency in the file system code, the logging system can accumulate the writes of multiple system calls into each transaction. Thus a single commit may involve the writes of multiple complete system calls. In order to preserve atomicity, the logging system commits only when no file system system calls are underway.</p>
<p class="paragraph01">The idea of committing several transaction together is known as <span class="text_3">group commit</span>. Group commit allows several transactions to run concurrently and allows the file system to <span class="text_3">batch </span>several disk operations and issue a single disk operation to the disk driver. This allows the disk to schedule the writing of the blocks cleverly and write at the rate of the disk's bandwidth. Xv6's IDE driver doesn't support batching, but xv6's file system design allows for it.</p>
<p class="paragraph01">Xv6 dedicates a fixed amount of space on the disk to hold the log. The total number of blocks written by the system calls in a transaction must fit in that space. This has two consequences. No single system call can be allowed to write more distinct blocks than there is space in the log. This is not a problem for most system calls, but two of them can potentially write many blocks: <span class="text_3">write </span>and <span class="text_3">unlink</span>. A large file write may write many data blocks and many bitmap blocks as well as an inode block; unlinking a large file might write many bitmap blocks and an inode. Xv6's write system call breaks up large writes into multiple smaller writes that fit in the log, and <span class="text_3">unlink </span>doesn't cause problems because in practice the xv6 file system uses only one bitmap block. The other consequence of limited log space is that the logging system cannot allow a system call to start unless it is certain that the system call's writes will fit in the space remaining in the log.</p>
	<h3 class="block_17">Code: logging</h3>
<p class="paragraph01">A typical use of the log in a system call looks like this:</p>
<p class="paragraph01">begin_op(); ... bp = bread(...); bp-&gt;data[...] = ...; log_write(bp);</p>
<p class="paragraph01">... end_op();</p>
<p class="paragraph01"><span class="text_3">begin_op </span><span class="text_5">(4628) </span>waits until the logging system is not currently committing, and until there is enough free log space to hold the writes from this call and all currently executing system calls. <span class="text_3">log.outstanding </span>counts that number of calls; the increment both reserves space and prevents a commit from occuring during this system call. The code conservatively assumes that each system call might write up to <span class="text_3">MAXOPBLOCKS </span>distinct blocks.</p>
<p class="paragraph01"><span class="text_3">log_write </span><span class="text_5">(4722) </span>acts as a proxy for <span class="text_3">bwrite</span>. It records the block's sector number in memory, reserving it a slot in the log on disk, and marks the buffer <span class="text_3">B_DIRTY </span>to prevent the block cache from evicting it. The block must stay in the cache until committed: until then, the cached copy is the only record of the modification; it cannot be written to its place on disk until after commit; and other reads in the same transaction must see the modifications. <span class="text_3">log_write </span>notices when a block is written multiple times during a single transaction, and allocates that block the same slot in the log. This optimization is often called <span class="text_3">absorption</span>. It is common that, for example, the disk block containing inodes of several files is written several times within a transaction. By absorbing several disk writes into one, the file system can save log space and can achieve better performance because only one copy of the disk block must be written to disk.</p>
<p class="paragraph01"><span class="text_3">end_op </span><span class="text_5">(4653) </span>first decrements the count of outstanding system calls. If the count is now zero, it commits the current transaction by calling <span class="text_3">commit(). </span>There are four stages in this process. <span class="text_3">write_log() </span><span class="text_5">(4683) </span>copies each block modified in the transaction from the buffer cache to its slot in the log on disk. <span class="text_3">write_head() </span><span class="text_5">(4604) </span>writes the header block to disk: this is the commit point, and a crash after the write will result in recovery replaying the transaction's writes from the log. <span class="text_3">install_trans() install_trans </span><span class="text_5">(4572) </span>reads each block from the log and write it to the proper place in the file system. Finally <span class="text_3">end_op </span>writes the log header with a count of zero; this has to happen before the next transaction starts writing logged blocks, so that a crash doesn't result in recovery using one transaction's header with the subsequent transaction's logged blocks.</p>
<p class="paragraph01"><span class="text_3">recover_from_log </span><span class="text_5">(4618) </span>is called from <span class="text_3">initlog </span><span class="text_5">(4556)</span>, which is called during boot before the first user process runs. <span class="text_5">(2794) </span>It reads the log header, and mimics the actions of <span class="text_3">end_op </span>if the header indicates that the log contains a committed transaction.</p>
<p class="paragraph01">An example use of the log occurs in <span class="text_3">filewrite </span><span class="text_5">(5752)</span>. The transaction looks like this:</p>
<p class="paragraph01">begin_op(); ilock(f-&gt;ip); r = writei(f-&gt;ip, ...); iunlock(f-&gt;ip); end_op();</p>
<p class="paragraph01">This code is wrapped in a loop that breaks up large writes into individual transactions of just a few sectors at a time, to avoid overflowing the log. The call to <span class="text_3">writei </span>writes many blocks as part of this transaction: the file's inode, one or more bitmap blocks, and some data blocks.</p>
	<h3 class="block_17">Code: Block allocator</h3>
<p class="paragraph01">File and directory content is stored in disk blocks, which must be allocated from a free pool. xv6's block allocator maintains a free bitmap on disk, with one bit per block. A zero bit indicates that the corresponding block is free; a one bit indicates that it is in use. The bits corresponding to the boot sector, superblock, inode blocks, and bitmap blocks are always set.</p>
<p class="paragraph01">The block allocator provides two functions: <span class="text_3">balloc </span>allocates a new disk block, and <span class="text_3">bfree </span>frees a block. <span class="text_3">Balloc </span><span class="text_5">(4804) </span>starts by calling <span class="text_3">readsb </span>to read the superblock from the disk (or buffer cache) into <span class="text_3">sb</span>. <span class="text_3">balloc </span>decides which blocks hold the data block free bitmap by calculating how many blocks are consumed by the boot sector, the superblock, and the inodes (using <span class="text_3">BBLOCK</span>). The loop <span class="text_5">(4812) </span>considers every block, starting at block 0 up to <span class="text_3">sb.size</span>, the number of blocks in the file system. It looks for a block whose bitmap bit is zero, indicating that it is free. If <span class="text_3">balloc </span>finds such a block, it updates the bitmap and returns the block. For efficiency, the loop is split into two pieces. The outer loop reads each block of bitmap bits. The inner loop checks all <span class="text_3">BPB </span>bits in a single bitmap block. The race that might occur if two processes try to allocate a block at the same time is prevented by the fact that the buffer cache only lets one process use any one bitmap block at a time.</p>
<p class="paragraph01"><span class="text_3">Bfree </span><span class="text_5">(4831) </span>finds the right bitmap block and clears the right bit. Again the exclusive use implied by <span class="text_3">bread </span>and <span class="text_3">brelse </span>avoids the need for explicit locking.</p>
<p class="paragraph01">As with much of the code described in the remainder of this chapter, <span class="text_3">balloc </span>and <span class="text_3">bfree </span>must be called inside a transaction.</p>
	<h3 class="block_56">Inode layer</h3>
<p class="paragraph01">The term <span class="text_3">inode </span>can have one of two related meanings. It might refer to the ondisk data structure containing a file's size and list of data block numbers. Or ''inode'' might refer to an in-memory inode, which contains a copy of the on-disk inode as well as extra information needed within the kernel.</p>
<p class="paragraph01">All of the on-disk inodes are packed into a contiguous area of disk called the inode blocks. Every inode is the same size, so it is easy, given a number n, to find the nth inode on the disk. In fact, this number n, called the inode number or i-number, is how inodes are identified in the implementation.</p>
<p class="paragraph01">The on-disk inode is defined by a <span class="text_3">struct dinode </span><span class="text_5">(3926)</span>. The <span class="text_3">type </span>field distinguishes between files, directories, and special files (devices). A type of zero indicates that an on-disk inode is free. The <span class="text_3">nlink </span>field counts the number of directory entries that refer to this inode, in order to recognize when the on-disk inode and its data blocks should be freed. The <span class="text_3">size </span>field records the number of bytes of content in the file. The <span class="text_3">addrs </span>array records the block numbers of the disk blocks holding the file's content.</p>
<p class="paragraph01">The kernel keeps the set of active inodes in memory; <span class="text_3">struct inode </span><span class="text_5">(4012) </span>is the in-memory copy of a <span class="text_3">struct dinode </span>on disk. The kernel stores an inode in memory only if there are C pointers referring to that inode. The <span class="text_3">ref </span>field counts the number of C pointers referring to the in-memory inode, and the kernel discards the inode from memory if the reference count drops to zero. The <span class="text_3">iget </span>and <span class="text_3">iput </span>functions acquire and release pointers to an inode, modifying the reference count. Pointers to an inode can come from file descriptors, current working directories, and transient kernel code such as <span class="text_3">exec</span>.</p>
<p class="paragraph01">A pointer returned by <span class="text_3">iget() </span>is guaranteed to be valid until the corresponding call to <span class="text_3">iput()</span>; the inode won't be deleted, and the memory referred to by the pointer won't be re-used for a different inode. <span class="text_3">iget() </span>provides non-exclusive access to an inode, so that there can be many pointers to the same inode. Many parts of the file system code depend on this behavior of <span class="text_3">iget()</span>, both to hold long-term references to inodes (as open files and current directories) and to prevent races while avoiding deadlock in code that manipulates multiple inodes (such as pathname lookup).</p>
<p class="paragraph01">The <span class="text_3">struct inode </span>that <span class="text_3">iget </span>returns may not have any useful content. In order to ensure it holds a copy of the on-disk inode, code must call <span class="text_3">ilock</span>. This locks the inode (so that no other process can <span class="text_3">ilock </span>it) and reads the inode from the disk, if it has not already been read. <span class="text_3">iunlock </span>releases the lock on the inode. Separating acquisition of inode pointers from locking helps avoid deadlock in some situations, for example during directory lookup. Multiple processes can hold a C pointer to an inode returned by <span class="text_3">iget</span>, but only one process can lock the inode at a time.</p>
<p class="paragraph01">The inode cache only caches inodes to which kernel code or data structures hold C pointers. Its main job is really synchronizing access by multiple processes, not caching. If an inode is used frequently, the buffer cache will probably keep it in memory if it isn't kept by the inode cache.</p>
	<h3 class="block_56">Code: Inodes</h3>
<p class="paragraph01">To allocate a new inode (for example, when creating a file), xv6 calls <span class="text_3">ialloc </span><span class="text_5">(4953)</span>. <span class="text_3">Ialloc </span>is similar to <span class="text_3">balloc</span>: it loops over the inode structures on the disk, one block at a time, looking for one that is marked free. When it finds one, it claims it by writing the new <span class="text_3">type </span>to the disk and then returns an entry from the inode cache with the tail call to <span class="text_3">iget </span><span class="text_5">(4970)</span>. The correct operation of <span class="text_3">ialloc </span>depends on the fact that only one process at a time can be holding a reference to <span class="text_3">bp</span>: <span class="text_3">ialloc </span>can be sure that some other process does not simultaneously see that the inode is available and try to claim it.</p>
<p class="paragraph01"><span class="text_3">Iget </span><span class="text_5">(5004) </span>looks through the inode cache for an active entry (<span class="text_3">ip-&gt;ref &gt; 0</span>) with the desired device and inode number. If it finds one, it returns a new reference to that inode. <span class="text_5">(5013-5017)</span>. As <span class="text_3">iget </span>scans, it records the position of the first empty slot <span class="text_5">(50185019)</span>, which it uses if it needs to allocate a cache entry.</p>
<p class="paragraph01">Code must lock the inode using <span class="text_3">ilock </span>before reading or writing its metadata or content. <span class="text_3">Ilock </span><span class="text_5">(5053) </span>uses a now-familiar sleep loop to wait for <span class="text_3">ip-&gt;flag</span>'s <span class="text_3">I_BUSY </span>bit to be clear and then sets it <span class="text_5">(5062-5064)</span>. Once <span class="text_3">ilock </span>has exclusive access to the inode, it can load the inode metadata from the disk (more likely, the buffer cache) if needed. The function <span class="text_3">iunlock </span><span class="text_5">(5085) </span>clears the <span class="text_3">I_BUSY </span>bit and wakes any processes sleeping in <span class="text_3">ilock</span>.</p>
<p class="paragraph01"><span class="text_3">Iput </span><span class="text_5">(5108) </span>releases a C pointer to an inode by decrementing the reference count <span class="text_5">(5124)</span>. If this is the last reference, the inode's slot in the inode cache is now free and can be re-used for a different inode.</p>
<p class="paragraph01">If <span class="text_3">iput </span>sees that there are no C pointer references to an inode and that the inode has no links to it (occurs in no directory), then the inode and its data blocks must be freed. <span class="text_3">Iput </span>relocks the inode; calls <span class="text_3">itrunc </span>to truncate the file to zero bytes, freeing the data blocks; sets the inode type to 0 (unallocated); writes the change to disk; and finally unlocks the inode <span class="text_5">(5111-5123)</span>.</p>
<p class="paragraph01">The locking protocol in <span class="text_3">iput </span>in the case in which it frees the inode deserves a closer look. First, when locking <span class="text_3">ip </span>by setting <span class="text_3">I_BUSY</span>, <span class="text_3">iput </span>assumes that it is unlocked. This must be the case: the caller is required to unlock <span class="text_3">ip </span>before calling <span class="text_3">iput</span>, and no other process can lock this inode, because no other process can get a pointer to it. That is because, in this code path, the inode has no references, no links (i.e., no pathname refers to it), and is not (yet) marked free. The second part worth examining is that <span class="text_3">iput </span>temporarily releases <span class="text_5">(5116) </span>and reacquires <span class="text_5">(5120) </span>the inode cache lock, because <span class="text_3">itrunc </span>and <span class="text_3">iupdate </span>will sleep during disk i/o. But we must consider what might happen while the lock is not held. Specifically, once <span class="text_3">iupdate </span>finishes, the ondisk inode is marked as free, and a concurrent call to <span class="text_3">ialloc </span>might find it and reallocate it before <span class="text_3">iput </span>can finish. <span class="text_3">Ialloc </span>will return a reference to the block by calling <span class="text_3">iget</span>, which will find <span class="text_3">ip </span>in the cache, see that its <span class="text_3">I_BUSY </span>flag is set, and sleep. Now the in-core inode is out of sync compared to the disk: <span class="text_3">ialloc </span>reinitialized the disk version but relies on the caller to load it into memory during <span class="text_3">ilock</span>. In order to make sure that this happens, <span class="text_3">iput </span>must clear not only <span class="text_3">I_BUSY </span>but also <span class="text_3">I_VALID </span>before releasing the inode lock. It does this by zeroing <span class="text_3">flags </span><span class="text_5">(5121)</span>.</p>
<p class="paragraph01"><span class="text_3">iput() </span>can write the disk. This means that any system call that uses the file sys-</p>
<p class="paragraph01">tem may write the disk, even calls like <span class="text_3">read() </span>that appear to be read-only. This, in turn, means that even read-only system calls must be wrapped in transactions if they use the file system.</p>
	<h3 class="block_41">Code: Inode content</h3>
<p class="paragraph01">The on-disk inode structure, <span class="text_3">struct dinode</span>, contains a size and an array of block numbers (see Figure 6-4). The inode data is found in the blocks listed in the <span class="text_3">dinode</span>'s <span class="text_3">addrs </span>array. The first <span class="text_3">NDIRECT </span>blocks of data are listed in the first <span class="text_3">NDIRECT </span>entries in the array; these blocks are called <span class="text_3">direct blocks</span>. The next <span class="text_3">NINDIRECT </span>blocks of data are listed not in the inode but in a data block called the <span class="text_3">indirect block</span>. The last entry in the <span class="text_3">addrs </span>array gives the address of the indirect block. Thus the first 6 kB (<span class="text_3">NDIRECT</span>×<span class="text_3">BSIZE</span>) bytes of a file can be loaded from blocks listed in the inode, while the next <span class="text_3">64</span>kB (<span class="text_3">NINDIRECT</span>×<span class="text_3">BSIZE</span>) bytes can only be loaded after consulting the indirect block. This is a good on-disk representation but a complex one for clients. The function <span class="text_3">bmap </span>manages the representation so that higher-level routines such as <span class="text_3">readi </span>and <span class="text_3">writei</span>, which we will see shortly. <span class="text_3">Bmap </span>returns the disk block number of the <span class="text_3">bn</span>'th data block for the inode <span class="text_3">ip</span>. If <span class="text_3">ip </span>does not have such a block yet, <span class="text_3">bmap </span>allocates one.</p>
<p class="paragraph01">The function <span class="text_3">bmap </span><span class="text_5">(5160) </span>begins by picking off the easy case: the first <span class="text_3">NDIRECT </span>blocks are listed in the inode itself <span class="text_5">(5165-5169)</span>. The next <span class="text_3">NINDIRECT </span>blocks are listed in the indirect block at <span class="text_3">ip-&gt;addrs[NDIRECT]</span>. <span class="text_3">Bmap </span>reads the indirect block <span class="text_5">(5176) </span>and then reads a block number from the right position within the block <span class="text_5">(5177)</span>. If the block number exceeds <span class="text_3">NDIRECT+NINDIRECT</span>, <span class="text_3">bmap </span>panics; <span class="text_3">writei </span>contains the check that prevents this from happening <span class="text_5">(5315)</span>.</p>
<p class="paragraph01"><span class="text_3">Bmap </span>allocates blocks as needed. An <span class="text_3">ip-&gt;addrs[] </span>or indirect entry of zero indicates that no block is allocated. As <span class="text_3">bmap </span>encounters zeros, it replaces them with the numbers of fresh blocks, allocated on demand. <span class="text_5">(5166-5167, 5174-5175)</span>.</p>
<p class="paragraph01"><span class="text_3">itrunc </span>frees a file's blocks, resetting the inode's size to zero. <span class="text_3">Itrunc </span><span class="text_5">(5206) </span>starts</p>
<p class="paragraph01"><span class="text_4">by freeing the direct blocks </span><span class="text_5">(5212-5217)</span><span class="text_4">, then the ones listed in the indirect block </span><span class="text_5">(52225225)</span><span class="text_4">, and finally the indirect block itself </span><span class="text_5">(5227-5228)</span><span class="text_4">.</span></p>
<p class="paragraph01"><span class="text_5"></span><span class="text_3">Bmap </span>makes it easy for <span class="text_3">readi </span>and <span class="text_3">writei </span>to get at an inode's data. <span class="text_3">Readi </span><span class="text_5">(5252) </span>starts by making sure that the offset and count are not beyond the end of the file. Reads that start beyond the end of the file return an error <span class="text_5">(5263-5264) </span>while reads that start at or cross the end of the file return fewer bytes than requested <span class="text_5">(5265-5266)</span>. The main loop processes each block of the file, copying data from the buffer into <span class="text_3">dst </span><span class="text_5">(5268-5273)</span>. <span class="text_3">writei </span><span class="text_5">(5302) </span>is identical to <span class="text_3">readi</span>, with three exceptions: writes that start at or cross the end of the file grow the file, up to the maximum file size <span class="text_5">(5315-5316)</span>; the loop copies data into the buffers instead of out <span class="text_5">(5321)</span>; and if the write has extended the file, <span class="text_3">writei </span>must update its size <span class="text_5">(5326-5329)</span>.</p>
<p class="paragraph01">type</p>
<p class="paragraph01">major</p>
<p class="paragraph01">minor</p>
<p class="paragraph01">nlink</p>
<p class="paragraph01">size</p>
<p class="paragraph01">address<span class="text_16"> </span>1</p>
<p class="paragraph01">.....</p>
<p class="paragraph01">address<span class="text_16"> </span>12</p>
<p class="paragraph01">indirect</p>
<p class="paragraph01">dinode</p>
<p class="paragraph01">address<span class="text_16"> </span>1</p>
<p class="paragraph01">address<span class="text_16"> </span>128</p>
<p class="paragraph01">.....</p>
<p class="paragraph01">indirect<span class="text_16"> </span>block</p>
<p class="paragraph01">data</p>
<p class="paragraph01">data</p>
<p class="paragraph01">data</p>
<p class="paragraph01">data</p>
<p class="paragraph01">...</p>
<p class="paragraph01">...</p>
<p class="paragraph01"><b>Figure</b> <b>6-4</b></p>
<p class="paragraph01">.<span class="text_19"> </span>The representation of a</p>
<p class="paragraph01">file on disk.</p>
<p class="paragraph01">type</p>
<p class="paragraph01">major</p>
<p class="paragraph01">minor</p>
<p class="paragraph01">nlink</p>
<p class="paragraph01">size</p>
<p class="paragraph01">address<span class="text_16"> </span>1</p>
<p class="paragraph01">.....</p>
<p class="paragraph01">address<span class="text_16"> </span>12</p>
<p class="paragraph01">indirect</p>
<p class="paragraph01">dinode</p>
<p class="paragraph01">address<span class="text_16"> </span>1</p>
<p class="paragraph01">address<span class="text_16"> </span>128</p>
<p class="paragraph01">.....</p>
<p class="paragraph01">indirect<span class="text_16"> </span>block</p>
<p class="paragraph01">data</p>
<p class="paragraph01">data</p>
<p class="paragraph01">data</p>
<p class="paragraph01">data</p>
<p class="paragraph01">...</p>
<p class="paragraph01">...</p>
<p class="paragraph01"><b>Figure</b> <b>6-4</b></p>
<p class="paragraph01">.<span class="text_19"> </span>The representation of a</p>
<p class="paragraph01">file on disk.</p>
<p class="paragraph01">Both <span class="text_3">readi </span>and <span class="text_3">writei </span>begin by checking for <span class="text_3">ip-&gt;type == T_DEV</span>. This case handles special devices whose data does not live in the file system; we will return to this case in the file descriptor layer.</p>
<p class="paragraph01">The function <span class="text_3">stati </span><span class="text_5">(4773) </span>copies inode metadata into the <span class="text_3">stat </span>structure, which is exposed to user programs via the <span class="text_3">stat </span>system call.</p>
	<h3 class="block_56">Code: directory layer</h3>
<p class="paragraph01">A directory is implemented internally much like a file. Its inode has type <span class="text_3">T_DIR </span>and its data is a sequence of directory entries. Each entry is a <span class="text_3">struct dirent </span><span class="text_5">(3950)</span>, which contains a name and an inode number. The name is at most <span class="text_3">DIRSIZ </span>(14) characters; if shorter, it is terminated by a NUL (0) byte. Directory entries with inode number zero are free.</p>
<p class="paragraph01">The function <span class="text_3">dirlookup </span><span class="text_5">(5361) </span>searches a directory for an entry with the given name. If it finds one, it returns a pointer to the corresponding inode, unlocked, and sets <span class="text_3">*poff </span>to the byte offset of the entry within the directory, in case the caller wishes to edit it. If <span class="text_3">dirlookup </span>finds an entry with the right name, it updates <span class="text_3">*poff</span>, releases the block, and returns an unlocked inode obtained via <span class="text_3">iget</span>. <span class="text_3">Dirlookup </span>is the reason that <span class="text_3">iget </span>returns unlocked inodes. The caller has locked <span class="text_3">dp</span>, so if the lookup was for <span class="text_3">.</span>, an alias for the current directory, attempting to lock the inode before returning would try to re-lock <span class="text_3">dp </span>and deadlock. (There are more complicated deadlock scenarios involving multiple processes and <span class="text_3">..</span>, an alias for the parent directory; <span class="text_3">. </span>is not the only problem.) The caller can unlock <span class="text_3">dp </span>and then lock <span class="text_3">ip</span>, ensuring that it only holds one lock at a time.</p>
<p class="paragraph01">The function <span class="text_3">dirlink </span><span class="text_5">(5402) </span>writes a new directory entry with the given name and inode number into the directory <span class="text_3">dp</span>. If the name already exists, <span class="text_3">dirlink </span>returns an error <span class="text_5">(5408-5412)</span>. The main loop reads directory entries looking for an unallocated entry. When it finds one, it stops the loop early <span class="text_5">(5372-5373)</span>, with <span class="text_3">off </span>set to the offset of the available entry. Otherwise, the loop ends with <span class="text_3">off </span>set to <span class="text_3">dp-&gt;size</span>. Either way, <span class="text_3">dirlink </span>then adds a new entry to the directory by writing at offset <span class="text_3">off </span><span class="text_5">(5422-5425)</span>.</p>
	<h3 class="block_90">Code: Path names</h3>
<p class="paragraph01">Path name lookup involves a succession of calls to <span class="text_3">dirlookup</span>, one for each path component. <span class="text_3">Namei </span><span class="text_5">(5540) </span>evaluates <span class="text_3">path </span>and returns the corresponding <span class="text_3">inode</span>. The function <span class="text_3">nameiparent </span>is a variant: it stops before the last element, returning the inode of the parent directory and copying the final element into <span class="text_3">name</span>. Both call the generalized function <span class="text_3">namex </span>to do the real work.</p>
<p class="paragraph01"><span class="text_3">Namex </span><span class="text_5">(5505) </span>starts by deciding where the path evaluation begins. If the path begins with a slash, evaluation begins at the root; otherwise, the current directory <span class="text_5">(55095512)</span>. Then it uses <span class="text_3">skipelem </span>to consider each element of the path in turn <span class="text_5">(5514)</span>. Each iteration of the loop must look up <span class="text_3">name </span>in the current inode <span class="text_3">ip</span>. The iteration begins by locking <span class="text_3">ip </span>and checking that it is a directory. If not, the lookup fails <span class="text_5">(5515-5519)</span>. (Locking <span class="text_3">ip </span>is necessary not because <span class="text_3">ip-&gt;type </span>can change underfoot—it can't—but because until <span class="text_3">ilock </span>runs, <span class="text_3">ip-&gt;type </span>is not guaranteed to have been loaded from disk.) If the call is <span class="text_3">nameiparent </span>and this is the last path element, the loop stops early, as per the definition of <span class="text_3">nameiparent</span>; the final path element has already been copied into <span class="text_3">name</span>, so <span class="text_3">namex </span>need only return the unlocked <span class="text_3">ip </span><span class="text_5">(5520-5524)</span>. Finally, the loop looks for the path element using <span class="text_3">dirlookup </span>and prepares for the next iteration by setting <span class="text_3">ip = next </span><span class="text_5">(5525-5530)</span>. When the loop runs out of path elements, it returns <span class="text_3">ip</span>.</p>
	<h3 class="block_17">File descriptor layer</h3>
<p class="paragraph01">One of the cool aspect of the Unix interface is that most resources in Unix are represented as a file, including devices such as the console, pipes, and of course, real files. The file descriptor layer is the layer that achieves this uniformity.</p>
<p class="paragraph01">Xv6 gives each process its own table of open files, or file descriptors, as we saw in Chapter 0. Each open file is represented by a <span class="text_3">struct file </span><span class="text_5">(4000)</span>, which is a wrapper around either an inode or a pipe, plus an i/o offset. Each call to <span class="text_3">open </span>creates a new open file (a new <span class="text_3">struct file</span>): if multiple processes open the same file independently, the different instances will have different i/o offsets. On the other hand, a single open file (the same <span class="text_3">struct file</span>) can appear multiple times in one process's file table and also in the file tables of multiple processes. This would happen if one process used <span class="text_3">open </span>to open the file and then created aliases using <span class="text_3">dup </span>or shared it with a child using <span class="text_3">fork</span>. A reference count tracks the number of references to a particular open file. A file can be open for reading or writing or both. The <span class="text_3">readable </span>and <span class="text_3">writable </span>fields track this.</p>
<p class="paragraph01">All the open files in the system are kept in a global file table, the <span class="text_3">ftable</span>. The file table has a function to allocate a file (<span class="text_3">filealloc</span>), create a duplicate reference (<span class="text_3">filedup</span>), release a reference (<span class="text_3">fileclose</span>), and read and write data (<span class="text_3">fileread </span>and <span class="text_3">filewrite</span>).</p>
<p class="paragraph01">The first three follow the now-familiar form. <span class="text_3">Filealloc </span><span class="text_5">(5625) </span>scans the file table for an unreferenced file (<span class="text_3">f-&gt;ref == 0</span>) and returns a new reference; <span class="text_3">filedup </span><span class="text_5">(5652) </span>increments the reference count; and <span class="text_3">fileclose </span><span class="text_5">(5664) </span>decrements it. When a file's reference count reaches zero, <span class="text_3">fileclose </span>releases the underlying pipe or inode, according to the type.</p>
<p class="paragraph01">The functions <span class="text_3">filestat</span>, <span class="text_3">fileread</span>, and <span class="text_3">filewrite </span>implement the <span class="text_3">stat</span>, <span class="text_3">read</span>, and <span class="text_3">write </span>operations on files. <span class="text_3">Filestat </span><span class="text_5">(5702) </span>is only allowed on inodes and calls <span class="text_3">stati</span>. <span class="text_3">Fileread </span>and <span class="text_3">filewrite </span>check that the operation is allowed by the open mode and then pass the call through to either the pipe or inode implementation. If the file represents an inode, <span class="text_3">fileread </span>and <span class="text_3">filewrite </span>use the i/o offset as the offset for the operation and then advance it <span class="text_5">(5725-5726, 5765-5766)</span>. Pipes have no concept of offset. Recall that the inode functions require the caller to handle locking <span class="text_5">(5705-5707, 57245727, 5764-5778)</span>. The inode locking has the convenient side effect that the read and write offsets are updated atomically, so that multiple writing to the same file simultaneously cannot overwrite each other's data, though their writes may end up interlaced.</p>
	<h3 class="block_17">Code: System calls</h3>
<p class="paragraph01">With the functions that the lower layers provide the implementation of most system calls is trivial (see <span class="text_3">sysfile.c</span>). There are a few calls that deserve a closer look.</p>
<p class="paragraph01">The functions <span class="text_3">sys_link </span>and <span class="text_3">sys_unlink </span>edit directories, creating or removing references to inodes. They are another good example of the power of using transactions. <span class="text_3">Sys_link </span><span class="text_5">(5913) </span>begins by fetching its arguments, two strings <span class="text_3">old </span>and <span class="text_3">new </span><span class="text_5">(5918)</span>. Assuming <span class="text_3">old </span>exists and is not a directory <span class="text_5">(5922-5925)</span>, <span class="text_3">sys_link </span>increments its <span class="text_3">ip&gt;nlink </span>count. Then <span class="text_3">sys_link </span>calls <span class="text_3">nameiparent </span>to find the parent directory and final path element of <span class="text_3">new </span><span class="text_5">(5938) </span>and creates a new directory entry pointing at <span class="text_3">old</span>'s inode <span class="text_5">(5941)</span>. The new parent directory must exist and be on the same device as the existing inode: inode numbers only have a unique meaning on a single disk. If an error like this occurs, <span class="text_3">sys_link </span>must go back and decrement <span class="text_3">ip-&gt;nlink</span>.</p>
<p class="paragraph01">Transactions simplify the implementation because it requires updating multiple disk blocks, but we don't have to worry about the order in which we do them. They either will all succeed or none. For example, without transactions, updating <span class="text_3">ip-&gt;nlink </span>before creating a link, would put the file system temporarily in an unsafe state, and a crash in between could result in havoc. With transactions we don't have to worry about this.</p>
<p class="paragraph01"><span class="text_3">Sys_link </span>creates a new name for an existing inode. The function <span class="text_3">create </span><span class="text_5">(6057) </span>creates a new name for a new inode. It is a generalization of the three file creation system calls: <span class="text_3">open </span>with the <span class="text_3">O_CREATE </span>flag makes a new ordinary file, <span class="text_3">mkdir </span>makes a new directoryy, and <span class="text_3">mkdev </span>makes a new device file. Like <span class="text_3">sys_link</span>, <span class="text_3">create </span>starts by caling <span class="text_3">nameiparent </span>to get the inode of the parent directory. It then calls <span class="text_3">dirlookup </span>to check whether the name already exists <span class="text_5">(6067)</span>. If the name does exist, <span class="text_3">create</span>'s behavior depends on which system call it is being used for: <span class="text_3">open </span>has different semantics from <span class="text_3">mkdir </span>and <span class="text_3">mkdev</span>. If <span class="text_3">create </span>is being used on behalf of <span class="text_3">open </span>(<span class="text_3">type == T_FILE</span>) and the name that exists is itself a regular file, then <span class="text_3">open </span>treats that as a success, so <span class="text_3">create </span>does too <span class="text_5">(6071)</span>. Otherwise, it is an error <span class="text_5">(6072-6073)</span>. If the name does not already exist, <span class="text_3">create </span>now allocates a new inode with <span class="text_3">ialloc </span><span class="text_5">(6076)</span>. If the new inode is a directory, <span class="text_3">create </span>initializes it with <span class="text_3">. </span>and <span class="text_3">.. </span>entries. Finally, now that the data is initialized properly, <span class="text_3">create </span>can link it into the parent directory <span class="text_5">(6089)</span>. <span class="text_3">Create</span>, like <span class="text_3">sys_link</span>, holds two inode locks simultaneously: <span class="text_3">ip </span>and <span class="text_3">dp</span>. There is no possibility of deadlock because the inode <span class="text_3">ip </span>is freshly allocated: no other process in the system will hold <span class="text_3">ip</span>'s lock and then try to lock <span class="text_3">dp</span>. Using <span class="text_3">create</span>, it is easy to implement <span class="text_3">sys_open</span>, <span class="text_3">sys_mkdir</span>, and <span class="text_3">sys_mknod</span>. <span class="text_3">Sys_open </span><span class="text_5">(6101) </span>is the most complex, because creating a new file is only a small part of what it can do. If <span class="text_3">open </span>is passed the <span class="text_3">O_CREATE </span>flag, it calls <span class="text_3">create </span><span class="text_5">(6114)</span>. Otherwise, it calls <span class="text_3">namei </span><span class="text_5">(6120)</span>. <span class="text_3">Create </span>returns a locked inode, but <span class="text_3">namei </span>does not, so <span class="text_3">sys_open </span>must lock the inode itself. This provides a convenient place to check that directories are only opened for reading, not writing. Assuming the inode was obtained one way or the other, <span class="text_3">sys_open </span>allocates a file and a file descriptor <span class="text_5">(6132) </span>and then fills in the file <span class="text_5">(6142-6146)</span>. Note that no other process can access the partially initialized file since it is only in the current process's table.</p>
<p class="paragraph01">Chapter 5 examined the implementation of pipes before we even had a file system. The function <span class="text_3">sys_pipe </span>connects that implementation to the file system by providing a way to create a pipe pair. Its argument is a pointer to space for two integers, where it will record the two new file descriptors. Then it allocates the pipe and installs the file descriptors.</p>
	<h3 class="block_17">Real world</h3>
<p class="paragraph01">The buffer cache in a real-world operating system is significantly more complex than xv6's, but it serves the same two purposes: caching and synchronizing access to the disk. Xv6's buffer cache, like V6's, uses a simple least recently used (LRU) eviction policy; there are many more complex policies that can be implemented, each good for some workloads and not as good for others. A more efficient LRU cache would eliminate the linked list, instead using a hash table for lookups and a heap for LRU evictions. Modern buffer caches are typically integrated with the virtual memory system to support memory-mapped files.</p>
<p class="paragraph01">Xv6's logging system is inefficient. A commit cannot occur concurrently with file system system calls. The system logs entire blocks, even if only a few bytes in a block are changed. It performs synchronous log writes, a block at a time, each of which is likely to require an entire disk rotation time. Real logging systems address all of these problems.</p>
<p class="paragraph01">Logging is not the only way to provide crash recovery. Early file systems used a scavenger during reboot (for example, the UNIX <span class="text_3">fsck </span>program) to examine every file and directory and the block and inode free lists, looking for and resolving inconsistencies. Scavenging can take hours for large file systems, and there are situations where it is not possible to resolve inconsistencies in a way that causes the original system calls to be atomic. Recovery from a log is much faster and causes system calls to be atomic in the face of crashes.</p>
<p class="paragraph01">Xv6 uses the same basic on-disk layout of inodes and directories as early UNIX; this scheme has been remarkably persistent over the years. BSD's UFS/FFS and Linux's ext2/ext3 use essentially the same data structures. The most inefficient part of the file system layout is the directory, which requires a linear scan over all the disk blocks during each lookup. This is reasonable when directories are only a few disk blocks, but is expensive for directories holding many files. Microsoft Windows's NTFS, Mac OS X's HFS, and Solaris's ZFS, just to name a few, implement a directory as an on-disk balanced tree of blocks. This is complicated but guarantees logarithmic-time directory lookups.</p>
<p class="paragraph01">Xv6 is naive about disk failures: if a disk operation fails, xv6 panics. Whether this is reasonable depends on the hardware: if an operating systems sits atop special hardware that uses redundancy to mask disk failures, perhaps the operating system sees failures so infrequently that panicking is okay. On the other hand, operating systems using plain disks should expect failures and handle them more gracefully, so that the loss of a block in one file doesn't affect the use of the rest of the file system.</p>
<p class="paragraph01">Xv6 requires that the file system fit on one disk device and not change in size. As large databases and multimedia files drive storage requirements ever higher, operating systems are developing ways to eliminate the ''one disk per file system'' bottleneck. The basic approach is to combine many disks into a single logical disk. Hardware solutions such as RAID are still the most popular, but the current trend is moving toward implementing as much of this logic in software as possible. These software implementations typically allow rich functionality like growing or shrinking the logical device by adding or removing disks on the fly. Of course, a storage layer that can grow or shrink on the fly requires a file system that can do the same: the fixed-size array of inode blocks used by xv6 would not work well in such environments. Separating disk management from the file system may be the cleanest design, but the complex interface between the two has led some systems, like Sun's ZFS, to combine them.</p>
<p class="paragraph01">Xv6's file system lacks many other features of modern file systems; for example, it lacks support for snapshots and incremental backup.</p>
<p class="paragraph01">Modern Unix systems allow many kinds of resources to be accessed with the same system calls as on-disk storage: named pipes, network connections, remotely-accessed network file systems, and monitoring and control interfaces such as <span class="text_3">/proc</span>. Instead of xv6's <span class="text_3">if </span>statements in <span class="text_3">fileread </span>and <span class="text_3">filewrite</span>, these systems typically give each open file a table of function pointers, one per operation, and call the function pointer to invoke that inode's implementation of the call. Network file systems and user-level file systems provide functions that turn those calls into network RPCs and wait for the response before returning.</p>
	<h3 class="block_17">Exercises</h3>
	<ol class="list_">
	<li class="block_215">Why panic in balloc? Can xv6 recover?</li>
	<li class="block_215">Why panic in ialloc? Can xv6 recover?</li>
	<li class="block_215">Why doesn't filealloc panic when it runs out of files? Why is this more common and therefore worth handling?</li>
	<li class="block_216">Suppose the file corresponding to <span class="text_3">ip </span>gets unlinked by another process between <span class="text_3">sys_link</span>'s calls to <span class="text_3">iunlock(ip) </span>and <span class="text_3">dirlink</span>. Will the link be created correctly? Why or why not?</li>
</ol>
	<ol class="list_">
	<li value="6" class="block_92"><span class="text_3">create </span>makes four function calls (one to <span class="text_3">ialloc </span>and three to <span class="text_3">dirlink</span>) that it requires to succeed. If any doesn't, <span class="text_3">create </span>calls <span class="text_3">panic</span>. Why is this acceptable? Why can't any of those four calls fail?</li>
	<li class="block_92"><span class="text_3">sys_chdir </span>calls <span class="text_3">iunlock(ip) </span>before <span class="text_3">iput(cp-&gt;cwd)</span>, which might try to lock <span class="text_3">cp-&gt;cwd</span>, yet postponing <span class="text_3">iunlock(ip) </span>until after the <span class="text_3">iput </span>would not cause deadlocks. Why not?</li>
</ol>
<p class="block_4"> </p>
	</body></html>
