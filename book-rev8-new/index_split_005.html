<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
    <title>xv6 - DRAFT as of September 3, 2014</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<ol class="list_">
<li class="block_92">
<span class="text_2">
</span></li>
</ol>
	<p class="block_77">Chapter 5</p>
	<h1 id="id_Toc460887579" class="block_13">Scheduling</h1>
	<p class="block_80"><span class="text_2">Any operating system is likely to run with more processes than the computer has processors, and so a plan is needed to time-share the processors among the processes. Ideally the sharing would be transparent to user processes. A common approach is to provide each process with the illusion that it has its own virtual processor, and have the operating system </span><span class="text_3">multiplex </span><span class="text_2">multiple virtual processors on a single physical processor. This chapter explains how xv6 multiplexes a processor among several processes.</span></p>
	<h3 class="block_17">Multiplexing</h3>
	<p class="block_15"><span class="text_2">Xv6 multiplexes by switching each processor from one process to another in two situations. First, xv6’s </span><span class="text_3">sleep </span><span class="text_2">and </span><span class="text_3">wakeup </span><span class="text_2">mechanism switches when a process waits for device or pipe I/O to complete, or waits for a child to exit, or waits in the </span><span class="text_3">sleep </span><span class="text_2">system call. Second, xv6 periodically forces a switch when a process is executing user instructions. This multiplexing creates the illusion that each process has its own CPU, just as xv6 uses the memory allocator and hardware page tables to create the illusion that each process has its own memory.</span></p>
	<p class="block_14">Implementing multiplexing poses a few challenges. First, how to switch from one process to another? Xv6 uses the standard mechanism of context switching; although the idea is simple, the implementation is some of the most opaque code in the system. Second, how to do context switching transparently? Xv6 uses the standard technique of using the timer interrupt handler to drive context switches. Third, many CPUs may be switching among processes concurrently, and a locking plan is necessary to avoid races. Fourth, when a process has exited its memory and other resources must be freed, but it cannot do all of this itself because (for example) it can’t free its own kernel stack while still using it. Xv6 tries to solve these problems as simply as possible, but nevertheless the resulting code is tricky.</p>
	<p class="block_98">xv6 must provide ways for processes to coordinate among themselves. For exam-</p>
	<p class="block_152">ple, a parent process may need to wait for one of its children to exit, or a process reading a pipe may need to wait for some other process to write the pipe. Rather than make the waiting process waste CPU by repeatedly checking whether the desired event has happened, xv6 allows a process to give up the CPU and sleep waiting for an event, and allows another process to wake the first process up. Care is needed to avoid races that result in the loss of event notifications. As an example of these problems and their solution, this chapter examines the implementation of pipes.</p>
	<h3 class="block_17">Code: Context switching</h3>
	<p class="block_153"></p>
	<p class="block_19">Kernel</p>
	<p class="block_19">shell</p>
	<p class="block_19">cat</p>
	<p class="block_19">user</p>
	<p class="block_19">space</p>
	<p class="block_19">kernel</p>
	<p class="block_19">space</p>
	<p class="block_19">kstack</p>
	<p class="block_19"> </p>
	<p class="block_19">shell</p>
	<p class="block_19">kstack<span class="text_18"> </span></p>
	<p class="block_19">cat</p>
	<p class="block_19">kstack</p>
	<p class="block_19">scheduler</p>
	<p class="block_19">save</p>
	<p class="block_19">restore</p>
	<p class="block_19">swtch</p>
	<p class="block_19">swtch</p>
	<p class="block_19">Kernel</p>
	<p class="block_19">shell</p>
	<p class="block_19">cat</p>
	<p class="block_19">user</p>
	<p class="block_19">space</p>
	<p class="block_19">kernel</p>
	<p class="block_19">space</p>
	<p class="block_19">kstack</p>
	<p class="block_19"> </p>
	<p class="block_19">shell</p>
	<p class="block_19">kstack<span class="text_18"> </span></p>
	<p class="block_19">cat</p>
	<p class="block_19">kstack</p>
	<p class="block_19">scheduler</p>
	<p class="block_19">save</p>
	<p class="block_19">restore</p>
	<p class="block_19">swtch</p>
	<p class="block_19">swtch</p>
	<p class="block_154"><b class="calibre2">Figure 5-1</b>. Switching from one user process to another. In this example, xv6 runs with one CPU (and thus one scheduler thread).</p>
	<p class="block_155">As shown in Figure 5-1, to switch between processes, xv6 performs two kinds of context switches at a low level: from a process’s kernel thread to the current CPU’s scheduler thread, and from the scheduler thread to a process’s kernel thread. xv6 never directly switches from one user-space process to another; this happens by way of a user-kernel transition (system call or interrupt), a context switch to the scheduler, a context switch to a new process’s kernel thread, and a trap return. In this section we’ll example the mechanics of switching between a kernel thread and a scheduler thread.</p>
	<p class="block_18"><span class="text_6"></span><span class="text_7">Every xv6 process has its own kernel stack and register set, as we saw in Chapter 2. Each CPU has a separate scheduler thread for use when it is executing the scheduler rather than any process’s kernel thread. Switching from one thread to another involves saving the old thread’s CPU registers, and restoring previously-saved registers of the new thread; the fact that </span><span class="text_8">%esp </span><span class="text_7">and </span><span class="text_8">%eip </span><span class="text_7">are saved and restored means that the CPU will switch stacks and switch what code it is executing.</span></p>
	<p class="block_15"><span class="text_3">swtch </span><span class="text_2">doesn’t directly know about threads; it just saves and restores register sets, called </span><span class="text_3">contexts</span><span class="text_2">. When it is time for the process to give up the CPU, the process’s kernel thread will call </span><span class="text_3">swtch </span><span class="text_2">to save its own context and return to the scheduler context. Each context is represented by a </span><span class="text_3">struct context*</span><span class="text_2">, a pointer to a structure stored on the kernel stack involved. </span><span class="text_3">Swtch </span><span class="text_2">takes two arguments: </span><span class="text_3">struct context **old </span><span class="text_2">and </span><span class="text_3">struct context *new</span><span class="text_2">. It pushes the current CPU register onto the stack and saves the stack pointer in </span><span class="text_3">*old</span><span class="text_2">. Then </span><span class="text_3">swtch </span><span class="text_2">copies </span><span class="text_3">new </span><span class="text_2">to </span><span class="text_3">%esp, </span><span class="text_2">pops previously saved registers, and returns.</span></p>
	<p class="block_18"><span class="text_7">Instead of following the scheduler into </span><span class="text_8">swtch</span><span class="text_7">, let’s instead follow our user process back in. We saw in Chapter 3 that one possibility at the end of each interrupt is that </span><span class="text_8">trap </span><span class="text_7">calls </span><span class="text_8">yield</span><span class="text_7">. </span><span class="text_8">Yield </span><span class="text_7">in turn calls </span><span class="text_8">sched</span><span class="text_7">, which calls </span><span class="text_8">swtch </span><span class="text_7">to save the current context in </span><span class="text_8">proc-&gt;context </span><span class="text_7">and switch to the scheduler context previously saved in </span><span class="text_8">cpu-&gt;scheduler </span><span class="text_6">(2766)</span><span class="text_7">.</span></p>
	<p class="block_18"><span class="text_8">Swtch </span><span class="text_6">(2952) </span><span class="text_7">starts by loading its arguments off the stack into the registers </span><span class="text_8">%eax </span><span class="text_7">and </span><span class="text_8">%edx </span><span class="text_6">(2959-2960)</span><span class="text_7">; </span><span class="text_8">swtch </span><span class="text_7">must do this before it changes the stack pointer and can no longer access the arguments via </span><span class="text_8">%esp. </span><span class="text_7">Then </span><span class="text_8">swtch </span><span class="text_7">pushes the register state, creating a context structure on the current stack. Only the callee-save registers need to be saved; the convention on the x86 is that these are </span><span class="text_8">%ebp, %ebx, %esi, %ebp, </span><span class="text_7">and </span><span class="text_8">%esp. Swtch </span><span class="text_7">pushes the first four explicitly </span><span class="text_6">(2963-2966)</span><span class="text_7">; it saves the last implicitly as the </span><span class="text_8">struct context* </span><span class="text_7">written to </span><span class="text_8">*old </span><span class="text_6">(2969)</span><span class="text_7">. There is one more important register: the program counter </span><span class="text_8">%eip </span><span class="text_7">was saved by the </span><span class="text_8">call </span><span class="text_7">instruction that invoked </span><span class="text_8">swtch </span><span class="text_7">and is on the stack just above </span><span class="text_8">%ebp. </span><span class="text_7">Having saved the old context, </span><span class="text_8">swtch </span><span class="text_7">is ready to restore the new one. It moves the pointer to the new context into the stack pointer </span><span class="text_6">(2970)</span><span class="text_7">. The new stack has the same form as the old one that </span><span class="text_8">swtch </span><span class="text_7">just left—the new stack </span><span class="text_15">was </span><span class="text_7">the old one in a previous call to </span><span class="text_8">swtch</span><span class="text_7">—so </span><span class="text_8">swtch </span><span class="text_7">can invert the sequence to restore the new context. It pops the values for </span><span class="text_8">%edi, %esi, %ebx, </span><span class="text_7">and </span><span class="text_8">%ebp </span><span class="text_7">and then returns </span><span class="text_6">(2973-2977)</span><span class="text_7">. Because </span><span class="text_8">swtch </span><span class="text_7">has changed the stack pointer, the values restored and the instruction address returned to are the ones from the new context.</span></p>
	<p class="block_89"><span class="text_7">In our example, </span><span class="text_8">sched </span><span class="text_7">called </span><span class="text_8">swtch </span><span class="text_7">to switch to </span><span class="text_8">cpu-&gt;scheduler</span><span class="text_7">, the per-CPU scheduler context. That context had been saved by </span><span class="text_8">scheduler</span><span class="text_7">’s call to </span><span class="text_8">swtch </span><span class="text_6">(2728)</span><span class="text_7">. When the </span><span class="text_8">swtch </span><span class="text_7">we have been tracing returns, it returns not to </span><span class="text_8">sched </span><span class="text_7">but to </span><span class="text_8">scheduler</span><span class="text_7">, and its stack pointer points at the current CPU’s scheduler stack, not </span><span class="text_8">initproc</span><span class="text_7">’s kernel stack.</span></p>
	<h3 class="block_90">Code: Scheduling</h3>
	<p class="block_18"><span class="text_7">The last section looked at the low-level details of </span><span class="text_8">swtch</span><span class="text_7">; now let’s take </span><span class="text_8">swtch </span><span class="text_7">as a given and examine the conventions involved in switching from process to scheduler and back to process. A process that wants to give up the CPU must acquire the process table lock </span><span class="text_8">ptable.lock</span><span class="text_7">, release any other locks it is holding, update its own state (</span><span class="text_8">proc-&gt;state</span><span class="text_7">), and then call </span><span class="text_8">sched</span><span class="text_7">. </span><span class="text_8">Yield </span><span class="text_6">(2772) </span><span class="text_7">follows this convention, as do </span><span class="text_8">sleep </span><span class="text_7">and </span><span class="text_8">exit</span><span class="text_7">, which we will examine later. </span><span class="text_8">Sched </span><span class="text_7">double-checks those conditions </span><span class="text_6">(27572762) </span><span class="text_7">and then an implication of those conditions: since a lock is held, the CPU should be running with interrupts disabled. Finally, </span><span class="text_8">sched </span><span class="text_7">calls </span><span class="text_8">swtch </span><span class="text_7">to save the current context in </span><span class="text_8">proc-&gt;context </span><span class="text_7">and switch to the scheduler context in </span><span class="text_8">cpu-&gt;scheduler</span><span class="text_7">. </span><span class="text_8">Swtch </span><span class="text_7">returns on the scheduler’s stack as though </span><span class="text_8">scheduler</span><span class="text_7">’s </span><span class="text_8">swtch </span><span class="text_7">had returned </span><span class="text_6">(2728)</span><span class="text_7">. The scheduler continues the </span><span class="text_8">for </span><span class="text_7">loop, finds a process to run, switches to it, and the cycle repeats.</span></p>
	<p class="block_15"><span class="text_2">We just saw that xv6 holds </span><span class="text_3">ptable.lock </span><span class="text_2">across calls to </span><span class="text_3">swtch</span><span class="text_2">: the caller of </span><span class="text_3">swtch </span><span class="text_2">must already hold the lock, and control of the lock passes to the switched-to code. This convention is unusual with locks; the typical convention is the thread that acquires a lock is also responsible of releasing the lock, which makes it easier to reason about correctness. For context switching it is necessary to break the typical convention because </span><span class="text_3">ptable.lock </span><span class="text_2">protects invariants on the process’s </span><span class="text_3">state </span><span class="text_2">and </span><span class="text_3">context </span><span class="text_2">fields that are not true while executing in </span><span class="text_3">swtch</span><span class="text_2">. One example of a problem that could arise if </span><span class="text_3">ptable.lock </span><span class="text_2">were not held during </span><span class="text_3">swtch</span><span class="text_2">: a different CPU might decide to run the process after </span><span class="text_3">yield </span><span class="text_2">had set its state to </span><span class="text_3">RUNNABLE</span><span class="text_2">, but before </span><span class="text_3">swtch </span><span class="text_2">caused it to stop using its own kernel stack. The result would be two CPUs running on the same stack, which cannot be right.</span></p>
	<p class="block_18"><span class="text_7">A kernel thread always gives up its processor in </span><span class="text_8">sched </span><span class="text_7">and always switches to the same location in the scheduler, which (almost) always switches to a process in </span><span class="text_8">sched</span><span class="text_7">. Thus, if one were to print out the line numbers where xv6 switches threads, one would observe the following simple pattern: </span><span class="text_6">(2728)</span><span class="text_7">, </span><span class="text_6">(2766)</span><span class="text_7">, </span><span class="text_6">(2728)</span><span class="text_7">, </span><span class="text_6">(2766)</span><span class="text_7">, and so on. The procedures in which this stylized switching between two threads happens are sometimes referred to as </span><span class="text_8">coroutines</span><span class="text_7">; in this example, </span><span class="text_8">sched </span><span class="text_7">and </span><span class="text_8">scheduler </span><span class="text_7">are co-routines of each other.</span></p>
	<p class="block_18"><span class="text_7">There is one case when the scheduler’s </span><span class="text_8">swtch </span><span class="text_7">to a new process does not end up in </span><span class="text_8">sched</span><span class="text_7">. We saw this case in Chapter 2: when a new process is first scheduled, it begins at </span><span class="text_8">forkret </span><span class="text_6">(2783)</span><span class="text_7">. </span><span class="text_8">Forkret </span><span class="text_7">exists only to honor this convention by releasing the </span><span class="text_8">ptable.lock</span><span class="text_7">; otherwise, the new process could start at </span><span class="text_8">trapret</span><span class="text_7">.</span></p>
	<p class="block_18"><span class="text_8">Scheduler </span><span class="text_6">(2708) </span><span class="text_7">runs a simple loop: find a process to run, run it until it stops, repeat. </span><span class="text_8">scheduler </span><span class="text_7">holds </span><span class="text_8">ptable.lock </span><span class="text_7">for most of its actions, but releases the lock (and explicitly enables interrupts) once in each iteration of its outer loop. This is important for the special case in which this CPU is idle (can find no </span><span class="text_8">RUNNABLE </span><span class="text_7">process). If an idling scheduler looped with the lock continuously held, no other CPU that was running a process could ever perform a context switch or any process-related system call, and in particular could never mark a process as </span><span class="text_8">RUNNABLE </span><span class="text_7">so as to break the idling CPU out of its scheduling loop. The reason to enable interrupts periodically on an idling CPU is that there might be no </span><span class="text_8">RUNNABLE </span><span class="text_7">process because processes (e.g., the shell) are waiting for I/O; if the scheduler left interrupts disabled all the time, the I/O would never arrive.</span></p>
	<p class="block_18"><span class="text_7">The scheduler loops over the process table looking for a runnable process, one that has </span><span class="text_8">p-&gt;state == RUNNABLE</span><span class="text_7">. Once it finds a process, it sets the per-CPU current process variable </span><span class="text_8">proc</span><span class="text_7">, switches to the process’s page table with </span><span class="text_8">switchuvm</span><span class="text_7">, marks the process as </span><span class="text_8">RUNNING</span><span class="text_7">, and then calls </span><span class="text_8">swtch </span><span class="text_7">to start running it </span><span class="text_6">(2722-2728)</span><span class="text_7">.</span></p>
	<p class="block_15"><span class="text_2">One way to think about the structure of the scheduling code is that it arranges to enforce a set of invariants about each process, and holds </span><span class="text_3">ptable.lock </span><span class="text_2">whenever those invariants are not true. One invariant is that if a process is </span><span class="text_3">RUNNING</span><span class="text_2">, things must be set up so that a timer interrupt’s </span><span class="text_3">yield </span><span class="text_2">can correctly switch away from the process; this means that the CPU registers must hold the process’s register values (i.e. they aren’t actually in a </span><span class="text_3">context</span><span class="text_2">), </span><span class="text_3">%cr3 </span><span class="text_2">must refer to the process’s pagetable, </span><span class="text_3">%esp </span><span class="text_2">must refer to the process’s kernel stack so that </span><span class="text_3">swtch </span><span class="text_2">can push registers correctly, and </span><span class="text_3">proc </span><span class="text_2">must refer to the process’s </span><span class="text_3">proc[] </span><span class="text_2">slot. Another invariant is that if a process is </span><span class="text_3">RUNNABLE</span><span class="text_2">, things must be set up so that an idle CPU’s </span><span class="text_3">scheduler </span><span class="text_2">can run it; this means that </span><span class="text_3">p-&gt;context </span><span class="text_2">must hold the process’s kernel thread variables, that no CPU is executing on the process’s kernel stack, that no CPU’s </span><span class="text_3">%cr3 </span><span class="text_2">refers to the process’s page table, and that no CPU’s </span><span class="text_3">proc </span><span class="text_2">refers to the process.</span></p>
	<p class="block_15"><span class="text_2">Maintaining the above invariants is the reason why xv6 acquires </span><span class="text_3">ptable.lock </span><span class="text_2">in one thread (often in </span><span class="text_3">yield) </span><span class="text_2">and releases the lock in a different thread (the scheduler thread or another next kernel thread). Once the code has started to modify a running process’s state to make it </span><span class="text_3">RUNNABLE</span><span class="text_2">, it must hold the lock until it has finished restoring the invariants: the earliest correct release point is after </span><span class="text_3">scheduler </span><span class="text_2">stops using the process’s page table and clears </span><span class="text_3">proc</span><span class="text_2">. Similarly, once </span><span class="text_3">scheduler </span><span class="text_2">starts to convert a runnable process to </span><span class="text_3">RUNNING</span><span class="text_2">, the lock cannot be released until the kernel thread is completely running (after the </span><span class="text_3">swtch</span><span class="text_2">, e.g. in </span><span class="text_3">yield</span><span class="text_2">).</span></p>
	<p class="block_87"><span class="text_3">ptable.lock </span><span class="text_2">protects other things as well: allocation of process IDs and free process table slots, the interplay between </span><span class="text_3">exit </span><span class="text_2">and </span><span class="text_3">wait</span><span class="text_2">, the machinery to avoid lost wakeups (see next section), and probably other things too. It might be worth thinking about whether the different functions of </span><span class="text_3">ptable.lock </span><span class="text_2">could be split up, certainly for clarity and perhaps for performance.</span></p>
	<h3 class="block_17">Sleep and wakeup</h3>
	<p class="block_15"><span class="text_2">Scheduling and locks help conceal the existence of one process from another, but so far we have no abstractions that help processes intentionally interact. Sleep and wakeup fill that void, allowing one process to sleep waiting for an event and another process to wake it up once the event has happened. Sleep and wakeup are often called </span><span class="text_3">sequence coordination </span><span class="text_2">or </span><span class="text_3">conditional synchronization </span><span class="text_2">mechanisms, and there are many other similar mechanisms in the operating systems literature.</span></p>
	<p class="block_156">To illustrate what we mean, let’s consider a simple producer/consumer queue. This queue is similar to the one that feeds commands from processes to the IDE driver (see Chapter 3), but abstracts away all IDE-specific code. The queue allows one process to send a nonzero pointer to another process. If there were only one sender and one receiver, and they executed on different CPUs, and the compiler didn’t optimize too agressively, this implementation would be correct:</p>
	<div class="calibre10">
	<div class="block_132"><span class="bullet_">100 </span><span class="calibre6">struct q {</span></div>
	<div class="block_132"><span class="bullet_">101 </span><span class="calibre6">void *ptr;</span></div>
	<div class="block_133"><span class="bullet_">102 </span><span class="calibre6">};</span></div>
</div>
	<p class="block_157">103</p>
	<div class="calibre13">
	<div class="block_132"><span class="bullet_">104 </span><span class="calibre6">void*</span></div>
	<div class="block_132"><span class="bullet_">105 </span><span class="calibre6">send(struct q *q, void *p)</span></div>
	<div class="block_132"><span class="bullet_">106 </span><span class="calibre6">{</span></div>
	<div class="block_132"><span class="bullet_">107 </span><span class="calibre6">while(q-&gt;ptr != 0)</span></div>
	<div class="block_132"><span class="bullet_">108 </span><span class="calibre6">;</span></div>
	<div class="block_132"><span class="bullet_">109 </span><span class="calibre6">q-&gt;ptr = p;</span></div>
	<div class="block_133"><span class="bullet_">110 </span><span class="calibre6">}</span></div>
</div>
	<p class="block_157">111</p>
	<div class="calibre10">
	<div class="block_132"><span class="bullet_">112 </span><span class="calibre6">void*</span></div>
	<div class="block_132"><span class="bullet_">113 </span><span class="calibre6">recv(struct q *q)</span></div>
	<div class="block_132"><span class="bullet_">114 </span><span class="calibre6">{</span></div>
	<div class="block_133"><span class="bullet_">115 </span><span class="calibre6">void *p;</span></div>
</div>
	<p class="block_157">116</p>
	<div class="calibre13">
	<div class="block_132"><span class="bullet_">117 </span><span class="calibre6">while((p = q-&gt;ptr) == 0)</span></div>
	<div class="block_132"><span class="bullet_">118 </span><span class="calibre6">;</span></div>
	<div class="block_132"><span class="bullet_">119 </span><span class="calibre6">q-&gt;ptr = 0;</span></div>
	<div class="block_132"><span class="bullet_">120 </span><span class="calibre6">return p;</span></div>
	<div class="block_158"><span class="bullet_">121 </span><span class="calibre6">}</span></div>
</div>
	<p class="block_26"><span class="text_3">Send </span><span class="text_2">loops until the queue is empty (</span><span class="text_3">ptr == 0) </span><span class="text_2">and then puts the pointer </span><span class="text_3">p </span><span class="text_2">in the queue. </span><span class="text_3">Recv </span><span class="text_2">loops until the queue is non-empty and takes the pointer out. When run in different processes, </span><span class="text_3">send </span><span class="text_2">and </span><span class="text_3">recv </span><span class="text_2">both modify </span><span class="text_3">q-&gt;ptr</span><span class="text_2">, but </span><span class="text_3">send </span><span class="text_2">only writes the pointer when it is zero and </span><span class="text_3">recv </span><span class="text_2">only writes the pointer when it is nonzero, so no updates are lost.</span></p>
	<p class="block_15"><span class="text_2">The implementation above is expensive. If the sender sends rarely, the receiver will spend most of its time spinning in the </span><span class="text_3">while </span><span class="text_2">loop hoping for a pointer. The receiver’s CPU could find more productive work if there were a way for the receiver to</span></p>
	<p class="block_27"><span class="text_12"></span><span class="text_12">215<span class="tab">       </span>216</span></p>
	<p class="block_159">wait for wakeup forever</p>
	<p class="block_160">test<span class="tab">       </span>sleep recv</p>
	<p class="block_161"></p>
	<p class="block_162">Time</p>
	<p class="block_27"><span class="text_12"></span><span class="text_12">send<span class="tab">       </span></span><span class="text_12"></span></p>
	<table class="table_">
		<tbody class="calibre14"><tr class="calibre15">
			<td class="td_"><p class="block_163">206</p><p class="block_164">store p</p></td>
			<td class="td_1"><p class="block_165">207 wakeup</p></td>
			<td class="td_1"><p class="block_166">204 test</p></td>
			<td class="td_2"><p class="block_163">205</p><p class="block_167">spin forever</p></td>
		</tr>
	</tbody></table>
	<p class="block_33"><b class="calibre2">Figure 5-2</b>. Example lost wakeup problem</p>
	<p class="block_168"><span class="text_2">yield the CPU and resume only when </span><span class="text_3">send </span><span class="text_2">delivered a pointer.</span></p>
	<p class="block_169"><span class="text_2">Let’s imagine a pair of calls, </span><span class="text_3">sleep </span><span class="text_2">and </span><span class="text_3">wakeup</span><span class="text_2">, that work as follows. </span><span class="text_3">Sleep(chan) </span><span class="text_2">sleeps on the arbitrary value </span><span class="text_3">chan</span><span class="text_2">, called the </span><span class="text_3">wait channel</span><span class="text_2">. </span><span class="text_3">Sleep </span><span class="text_2">puts the calling process to sleep, releasing the CPU for other work. </span><span class="text_3">Wakeup(chan) </span><span class="text_2">wakes all processes sleeping on </span><span class="text_3">chan </span><span class="text_2">(if any), causing their </span><span class="text_3">sleep </span><span class="text_2">calls to return. If no processes are waiting on </span><span class="text_3">chan</span><span class="text_2">, </span><span class="text_3">wakeup </span><span class="text_2">does nothing. We can change the queue implementation to use </span><span class="text_3">sleep </span><span class="text_2">and </span><span class="text_3">wakeup</span><span class="text_2">:</span></p>
	<div class="calibre13">
	<div class="block_132"><span class="bullet_">201 </span><span class="calibre6">void*</span></div>
	<div class="block_132"><span class="bullet_">202 </span><span class="calibre6">send(struct q *q, void *p)</span></div>
	<div class="block_132"><span class="bullet_">203 </span><span class="calibre6">{</span></div>
	<div class="block_132"><span class="bullet_">204 </span><span class="calibre6">while(q-&gt;ptr != 0)</span></div>
	<div class="block_170"><span class="bullet_">205 </span><span class="calibre6"><span class="text_6"></span><span class="text_27">;</span></span></div>
	<div class="block_132"><span class="bullet_">206 </span><span class="calibre6">q-&gt;ptr = p;</span></div>
	<div class="block_132"><span class="bullet_">207 </span><span class="calibre6">wakeup(q); /* wake recv */</span></div>
	<div class="block_133"><span class="bullet_">208 </span><span class="calibre6">}</span></div>
</div>
	<p class="block_157">209</p>
	<div class="calibre10">
	<div class="block_132"><span class="bullet_">210 </span><span class="calibre6">void*</span></div>
	<div class="block_132"><span class="bullet_">211 </span><span class="calibre6">recv(struct q *q)</span></div>
	<div class="block_132"><span class="bullet_">212 </span><span class="calibre6">{</span></div>
	<div class="block_133"><span class="bullet_">213 </span><span class="calibre6">void *p;</span></div>
</div>
	<p class="block_157">214</p>
	<div class="calibre10">
	<div class="block_171"><span class="bullet_">215 </span><span class="calibre6">while((p = q-&gt;ptr) == 0)</span></div>
	<div class="block_171"><span class="bullet_">216 </span><span class="calibre6">sleep(q); 217 <span class="tab">       </span>q-&gt;ptr = 0;</span></div>
</div>
	<div class="calibre10">
	<div class="block_132"><span class="bullet_">218 </span><span class="calibre6">return p;</span></div>
	<div class="block_172"><span class="bullet_">219 </span><span class="calibre6">}</span></div>
</div>
	<p class="block_15"><span class="text_3">Recv </span><span class="text_2">now gives up the CPU instead of spinning, which is nice. However, it turns out not to be straightforward to design </span><span class="text_3">sleep </span><span class="text_2">and </span><span class="text_3">wakeup </span><span class="text_2">with this interface without suffering from what is known as the ‘‘lost wake-up’’ problem (see Figure 5-2). Suppose that </span><span class="text_3">recv </span><span class="text_2">finds that </span><span class="text_3">q-&gt;ptr == 0 </span><span class="text_2">on line 215. While </span><span class="text_3">recv </span><span class="text_2">is between lines 215 and 216, </span><span class="text_3">send </span><span class="text_2">runs on another CPU: it changes </span><span class="text_3">q-&gt;ptr </span><span class="text_2">to be nonzero and calls </span><span class="text_3">wakeup</span><span class="text_2">, which finds no processes sleeping and thus does nothing. Now </span><span class="text_3">recv </span><span class="text_2">continues executing at line 216: it calls </span><span class="text_3">sleep </span><span class="text_2">and goes to sleep. This causes a problem: </span><span class="text_3">recv </span><span class="text_2">is asleep waiting for a pointer that has already arrived. The next </span><span class="text_3">send </span><span class="text_2">will sleep waiting for </span><span class="text_3">recv </span><span class="text_2">to consume the pointer in the queue, at which point the system will be </span><span class="text_3">deadlocked</span><span class="text_2">.</span></p>
	<p class="block_173"><span class="text_2">The root of this problem is that the invariant that </span><span class="text_3">recv </span><span class="text_2">only sleeps when </span><span class="text_3">q-&gt;ptr == 0 </span><span class="text_2">is violated by </span><span class="text_3">send </span><span class="text_2">running at just the wrong moment. One incorrect way of protecting the invariant would be to modify the code for </span><span class="text_3">recv </span><span class="text_2">as follows:</span></p>
	<div class="calibre10">
	<div class="block_132"><span class="bullet_">300 </span><span class="calibre6">struct q {</span></div>
	<div class="block_132"><span class="bullet_">301 </span><span class="calibre6">struct spinlock lock;</span></div>
	<div class="block_132"><span class="bullet_">302 </span><span class="calibre6">void *ptr;</span></div>
	<div class="block_133"><span class="bullet_">303 </span><span class="calibre6">};</span></div>
</div>
	<p class="block_157">304</p>
	<div class="calibre16">
	<div class="block_132"><span class="bullet_">305 </span><span class="calibre6">void*</span></div>
	<div class="block_132"><span class="bullet_">306 </span><span class="calibre6">send(struct q *q, void *p)</span></div>
	<div class="block_132"><span class="bullet_">307 </span><span class="calibre6">{</span></div>
	<div class="block_132"><span class="bullet_">308 </span><span class="calibre6">acquire(&amp;q-&gt;lock); 309 <span class="tab">       </span>while(q-&gt;ptr != 0)</span></div>
</div>
	<div class="calibre13">
	<div class="block_132"><span class="bullet_">310 </span><span class="calibre6">;</span></div>
	<div class="block_132"><span class="bullet_">311 </span><span class="calibre6">q-&gt;ptr = p;</span></div>
	<div class="block_132"><span class="bullet_">312 </span><span class="calibre6">wakeup(q);</span></div>
	<div class="block_132"><span class="bullet_">313 </span><span class="calibre6">release(&amp;q-&gt;lock);</span></div>
	<div class="block_133"><span class="bullet_">314 </span><span class="calibre6">}</span></div>
</div>
	<p class="block_157">315</p>
	<div class="calibre10">
	<div class="block_132"><span class="bullet_">316 </span><span class="calibre6">void*</span></div>
	<div class="block_132"><span class="bullet_">317 </span><span class="calibre6">recv(struct q *q)</span></div>
	<div class="block_132"><span class="bullet_">318 </span><span class="calibre6">{</span></div>
	<div class="block_133"><span class="bullet_">319 </span><span class="calibre6">void *p;</span></div>
</div>
	<p class="block_157">320</p>
	<div class="calibre10">
	<div class="block_132"><span class="bullet_">321 </span><span class="calibre6">acquire(&amp;q-&gt;lock);</span></div>
	<div class="block_132"><span class="bullet_">322 </span><span class="calibre6">while((p = q-&gt;ptr) == 0)</span></div>
	<div class="block_132"><span class="bullet_">323 </span><span class="calibre6">sleep(q); 324 <span class="tab">       </span>q-&gt;ptr = 0;</span></div>
</div>
	<div class="calibre10">
	<div class="block_132"><span class="bullet_">325 </span><span class="calibre6">release(&amp;q-&gt;lock);</span></div>
	<div class="block_132"><span class="bullet_">326 </span><span class="calibre6">return p;</span></div>
	<div class="block_174"><span class="bullet_">327 </span><span class="calibre6">}</span></div>
</div>
	<p class="block_26"><span class="text_2">One might hope that this version of </span><span class="text_3">recv </span><span class="text_2">would avoid the lost wakeup because the lock prevents </span><span class="text_3">send </span><span class="text_2">from executing between lines 322 and 323. It does that, but it also deadlocks: </span><span class="text_3">recv </span><span class="text_2">holds the lock while it sleeps, so the sender will block forever waiting for the lock.</span></p>
	<p class="block_175"><span class="text_2">We’ll fix the preceding scheme by passing the lock to </span><span class="text_3">sleep </span><span class="text_2">so it can release the lock after the calling process is marked as asleep and waiting on the sleep channel. The lock will force a concurrent </span><span class="text_3">send </span><span class="text_2">to wait until the receiver has finished putting itself to sleep, so that the </span><span class="text_3">wakeup </span><span class="text_2">will find the sleeping receiver and wake it up. Once the receiver is awake again </span><span class="text_3">sleep </span><span class="text_2">reacquires the lock before returning. Our new correct scheme is useable as follows:</span></p>
	<div class="calibre10">
	<div class="block_132"><span class="bullet_">400 </span><span class="calibre6">struct q {</span></div>
	<div class="block_132"><span class="bullet_">401 </span><span class="calibre6">struct spinlock lock;</span></div>
	<div class="block_132"><span class="bullet_">402 </span><span class="calibre6">void *ptr;</span></div>
	<div class="block_133"><span class="bullet_">403 </span><span class="calibre6">};</span></div>
</div>
	<p class="block_157">404</p>
	<div class="calibre16">
	<div class="block_132"><span class="bullet_">405 </span><span class="calibre6">void*</span></div>
	<div class="block_132"><span class="bullet_">406 </span><span class="calibre6">send(struct q *q, void *p)</span></div>
	<div class="block_132"><span class="bullet_">407 </span><span class="calibre6">{</span></div>
	<div class="block_132"><span class="bullet_">408 </span><span class="calibre6">acquire(&amp;q-&gt;lock); 409 <span class="tab">       </span>while(q-&gt;ptr != 0)</span></div>
</div>
	<div class="calibre13">
	<div class="block_132"><span class="bullet_">410 </span><span class="calibre6">;</span></div>
	<div class="block_132"><span class="bullet_">411 </span><span class="calibre6">q-&gt;ptr = p;</span></div>
	<div class="block_132"><span class="bullet_">412 </span><span class="calibre6">wakeup(q);</span></div>
	<div class="block_132"><span class="bullet_">413 </span><span class="calibre6">release(&amp;q-&gt;lock);</span></div>
	<div class="block_133"><span class="bullet_">414 </span><span class="calibre6">}</span></div>
</div>
	<p class="block_157">415</p>
	<div class="calibre10">
	<div class="block_132"><span class="bullet_">416 </span><span class="calibre6">void*</span></div>
	<div class="block_132"><span class="bullet_">417 </span><span class="calibre6">recv(struct q *q)</span></div>
	<div class="block_132"><span class="bullet_">418 </span><span class="calibre6">{</span></div>
	<div class="block_133"><span class="bullet_">419 </span><span class="calibre6">void *p;</span></div>
</div>
	<p class="block_157">420</p>
	<div class="calibre13">
	<div class="block_132"><span class="bullet_">421 </span><span class="calibre6">acquire(&amp;q-&gt;lock);</span></div>
	<div class="block_132"><span class="bullet_">422 </span><span class="calibre6">while((p = q-&gt;ptr) == 0)</span></div>
	<div class="block_132"><span class="bullet_">423 </span><span class="calibre6">sleep(q, &amp;q-&gt;lock);</span></div>
	<div class="block_132"><span class="bullet_">424 </span><span class="calibre6">q-&gt;ptr = 0;</span></div>
	<div class="block_132"><span class="bullet_">425 </span><span class="calibre6">release(&amp;q-&gt;lock);</span></div>
	<div class="block_132"><span class="bullet_">426 </span><span class="calibre6">return p;</span></div>
	<div class="block_176"><span class="bullet_">427 </span><span class="calibre6">}</span></div>
</div>
	<p class="block_15"><span class="text_2">The fact that </span><span class="text_3">recv </span><span class="text_2">holds </span><span class="text_3">q-&gt;lock </span><span class="text_2">prevents </span><span class="text_3">send </span><span class="text_2">from trying to wake it up between </span><span class="text_3">recv</span><span class="text_2">’s check of </span><span class="text_3">q-&gt;ptr </span><span class="text_2">and its call to </span><span class="text_3">sleep</span><span class="text_2">. Of course, the receiving process must release </span><span class="text_3">q-&gt;lock </span><span class="text_2">while it is sleeping so the sender can wake it up. So we want sleep to atomically release </span><span class="text_3">q-&gt;lock </span><span class="text_2">and put the receiving process to sleep.</span></p>
	<p class="block_125"><span class="text_2">A complete sender/receiver implementation would also sleep in </span><span class="text_3">send </span><span class="text_2">when waiting for a receiver to consume the value from a previous </span><span class="text_3">send</span><span class="text_2">.</span></p>
	<h3 class="block_90">Code: Sleep and wakeup</h3>
	<p class="block_15"><span class="text_2">Let’s look at the implementation of </span><span class="text_3">sleep </span><span class="text_2">and </span><span class="text_3">wakeup </span><span class="text_2">in xv6. The basic idea is to have </span><span class="text_3">sleep </span><span class="text_2">mark the current process as </span><span class="text_3">SLEEPING </span><span class="text_2">and then call </span><span class="text_3">sched </span><span class="text_2">to release the processor; </span><span class="text_3">wakeup </span><span class="text_2">looks for a process sleeping on the given wait channel and marks it as </span><span class="text_3">RUNNABLE</span><span class="text_2">.</span></p>
	<p class="block_122"><span class="text_8">Sleep </span><span class="text_6">(2803) </span><span class="text_7">begins with a few sanity checks: there must be a current process</span></p>
	<p class="block_88"><span class="text_6">(2805) </span><span class="text_7">and </span><span class="text_8">sleep </span><span class="text_7">must have been passed a lock </span><span class="text_6">(2808-2809)</span><span class="text_7">. Then </span><span class="text_8">sleep </span><span class="text_7">acquires </span><span class="text_8">ptable.lock </span><span class="text_6">(2818)</span><span class="text_7">. Now the process going to sleep holds both </span><span class="text_8">ptable.lock </span><span class="text_7">and </span><span class="text_8">lk</span><span class="text_7">. Holding </span><span class="text_8">lk </span><span class="text_7">was necessary in the caller (in the example, </span><span class="text_8">recv</span><span class="text_7">): it ensured that no other process (in the example, one running </span><span class="text_8">send</span><span class="text_7">) could start a call </span><span class="text_8">wakeup(chan)</span><span class="text_7">. Now that </span><span class="text_8">sleep </span><span class="text_7">holds </span><span class="text_8">ptable.lock</span><span class="text_7">, it is safe to release </span><span class="text_8">lk</span><span class="text_7">: some other process may start a call to </span><span class="text_8">wakeup(chan)</span><span class="text_7">, but </span><span class="text_8">wakeup </span><span class="text_7">will not run until it can acquire </span><span class="text_8">ptable.lock</span><span class="text_7">, so it must wait until </span><span class="text_8">sleep </span><span class="text_7">has finished putting the process to sleep, keeping the </span><span class="text_8">wakeup </span><span class="text_7">from missing the </span><span class="text_8">sleep</span><span class="text_7">.</span></p>
	<p class="block_18"><span class="text_7">There is a minor complication: if </span><span class="text_8">lk </span><span class="text_7">is equal to </span><span class="text_8">&amp;ptable.lock</span><span class="text_7">, then </span><span class="text_8">sleep </span><span class="text_7">would deadlock trying to acquire it as </span><span class="text_8">&amp;ptable.lock </span><span class="text_7">and then release it as </span><span class="text_8">lk</span><span class="text_7">. In this case, </span><span class="text_8">sleep </span><span class="text_7">considers the acquire and release to cancel each other out and skips them entirely </span><span class="text_6">(2817)</span><span class="text_7">. For example, </span><span class="text_8">wait </span><span class="text_6">(2653) </span><span class="text_7">calls </span><span class="text_8">sleep </span><span class="text_7">with </span><span class="text_8">&amp;ptable.lock</span><span class="text_7">.</span></p>
	<p class="block_18"><span class="text_7">Now that </span><span class="text_8">sleep </span><span class="text_7">holds </span><span class="text_8">ptable.lock </span><span class="text_7">and no others, it can put the process to sleep by recording the sleep channel, changing the process state, and calling </span><span class="text_8">sched </span><span class="text_6">(2823-2825)</span><span class="text_7">.</span></p>
	<p class="block_18"><span class="text_7">At some point later, a process will call </span><span class="text_8">wakeup(chan)</span><span class="text_7">. </span><span class="text_8">Wakeup </span><span class="text_6">(2853) </span><span class="text_7">acquires </span><span class="text_8">ptable.lock </span><span class="text_7">and calls </span><span class="text_8">wakeup1</span><span class="text_7">, which does the real work. It is important that </span><span class="text_8">wakeup </span><span class="text_7">hold the </span><span class="text_8">ptable.lock </span><span class="text_7">both because it is manipulating process states and because, as we just saw, </span><span class="text_8">ptable.lock </span><span class="text_7">makes sure that </span><span class="text_8">sleep </span><span class="text_7">and </span><span class="text_8">wakeup </span><span class="text_7">do not miss each other. </span><span class="text_8">Wakeup1 </span><span class="text_7">is a separate function because sometimes the scheduler needs to execute a wakeup when it already holds the </span><span class="text_8">ptable.lock</span><span class="text_7">; we will see an example of this later. </span><span class="text_8">Wakeup1 </span><span class="text_6">(2853) </span><span class="text_7">loops over the process table. When it finds a process in state </span><span class="text_8">SLEEPING </span><span class="text_7">with a matching </span><span class="text_8">chan</span><span class="text_7">, it changes that process’s state to </span><span class="text_8">RUNNABLE</span><span class="text_7">. The next time the scheduler runs, it will see that the process is ready to be run.</span></p>
	<p class="block_15"><span class="text_3">Wakeup </span><span class="text_2">must always be called while holding a lock that guards whatever the wakeup condition is; in the example above that lock is </span><span class="text_3">q-&gt;lock</span><span class="text_2">. The complete argument for why the sleeping process won’t miss a wakeup is that at all times from before it checks the condition until after it is asleep, it holds either the lock on the condition or the </span><span class="text_3">ptable.lock </span><span class="text_2">or both. Since </span><span class="text_3">wakeup </span><span class="text_2">executes while holding both of those locks, the wakeup must execute either before the potential sleeper checks the condition, or after the potential sleeper has completed putting itself to sleep.</span></p>
	<p class="block_15"><span class="text_2">It is sometimes the case that multiple processes are sleeping on the same channel; for example, more than one process trying to read from a pipe. A single call to </span><span class="text_3">wakeup </span><span class="text_2">will wake them all up. One of them will run first and acquire the lock that </span><span class="text_3">sleep </span><span class="text_2">was called with, and (in the case of pipes) read whatever data is waiting in the pipe. The other processes will find that, despite being woken up, there is no data to be read. From their point of view the wakeup was ‘‘spurious,’’ and they must sleep again. For this reason sleep is always called inside a loop that checks the condition.</span></p>
	<p class="block_40">Callers of sleep and wakeup can use any mutually convenient number as the channel; in practice xv6 often uses the address of a kernel data structure involved in the waiting, such as a disk buffer. No harm is done if two uses of sleep/wakeup accidentally choose the same channel: they will see spurious wakeups, but looping as described above will tolerate this problem. Much of the charm of sleep/wakeup is that it is both lightweight (no need to create special data structures to act as sleep channels) and provides a layer of indirection (callers need not know what specific process they are interacting with).</p>
	<h3 class="block_17">Code: Pipes</h3>
	<p class="block_26"><span class="text_2">The simple queue we used earlier in this chapter was a toy, but xv6 contains two real queues that uses </span><span class="text_3">sleep </span><span class="text_2">and </span><span class="text_3">wakeup </span><span class="text_2">to synchronize readers and writers. One is in the IDE driver: processes add a disk requests to a queue and then calls </span><span class="text_3">sleep</span><span class="text_2">. The interrupt handler uses </span><span class="text_3">wakeup </span><span class="text_2">to alert the process that its request has completed.</span></p>
	<p class="block_15"><span class="text_2">An more complex example is the implementation of pipes. We saw the interface for pipes in Chapter 0: bytes written to one end of a pipe are copied in an in-kernel buffer and then can be read out of the other end of the pipe. Future chapters will examine the file system support surrounding pipes, but let’s look now at the implementations of </span><span class="text_3">pipewrite </span><span class="text_2">and </span><span class="text_3">piperead</span><span class="text_2">.</span></p>
	<p class="block_15"><span class="text_2">Each pipe is represented by a </span><span class="text_3">struct pipe</span><span class="text_2">, which contains a </span><span class="text_3">lock </span><span class="text_2">and a </span><span class="text_3">data </span><span class="text_2">buffer. The fields </span><span class="text_3">nread </span><span class="text_2">and </span><span class="text_3">nwrite </span><span class="text_2">count the number of bytes read from and written to the buffer. The buffer wraps around: the next byte written after </span><span class="text_3">buf[PIPESIZE-1] </span><span class="text_2">is </span><span class="text_3">buf[0]</span><span class="text_2">, but the counts do not wrap. This convention lets the implementation distinguish a full buffer (</span><span class="text_3">nwrite == nread+PIPESIZE</span><span class="text_2">) from an empty buffer </span><span class="text_3">nwrite == nread</span><span class="text_2">), but it means that indexing into the buffer must use </span><span class="text_3">buf[nread % PIPESIZE] </span><span class="text_2">instead of just </span><span class="text_3">buf[nread] </span><span class="text_2">(and similarly for </span><span class="text_3">nwrite</span><span class="text_2">). Let’s suppose that calls to </span><span class="text_3">piperead </span><span class="text_2">and </span><span class="text_3">pipewrite </span><span class="text_2">happen simultaneously on two different CPUs.</span></p>
	<p class="block_18"><span class="text_8">Pipewrite </span><span class="text_6">(6530) </span><span class="text_7">begins by acquiring the pipe’s lock, which protects the counts, the data, and their associated invariants. </span><span class="text_8">Piperead </span><span class="text_6">(6551) </span><span class="text_7">then tries to acquire the lock too, but cannot. It spins in </span><span class="text_8">acquire </span><span class="text_6">(1574) </span><span class="text_7">waiting for the lock. While </span><span class="text_8">piperead </span><span class="text_7">waits, </span><span class="text_8">pipewrite </span><span class="text_7">loops over the bytes being written—</span><span class="text_8">addr[0]</span><span class="text_7">, </span><span class="text_8">addr[1]</span><span class="text_7">, ..., </span><span class="text_8">addr[n-1]</span><span class="text_7">— adding each to the pipe in turn </span><span class="text_6">(6544)</span><span class="text_7">. During this loop, it could happen that the buffer fills </span><span class="text_6">(6536)</span><span class="text_7">. In this case, </span><span class="text_8">pipewrite </span><span class="text_7">calls </span><span class="text_8">wakeup </span><span class="text_7">to alert any sleeping readers to the fact that there is data waiting in the buffer and then sleeps on </span><span class="text_8">&amp;p-&gt;nwrite </span><span class="text_7">to wait for a reader to take some bytes out of the buffer. </span><span class="text_8">Sleep </span><span class="text_7">releases </span><span class="text_8">p-&gt;lock </span><span class="text_7">as part of putting </span><span class="text_8">pipewrite</span><span class="text_7">’s process to sleep.</span></p>
	<p class="block_18"><span class="text_7">Now that </span><span class="text_8">p-&gt;lock </span><span class="text_7">is available, </span><span class="text_8">piperead </span><span class="text_7">manages to acquire it and start running in earnest: it finds that </span><span class="text_8">p-&gt;nread != p-&gt;nwrite </span><span class="text_6">(6556) </span><span class="text_7">(</span><span class="text_8">pipewrite </span><span class="text_7">went to sleep because </span><span class="text_8">p-&gt;nwrite == p-&gt;nread+PIPESIZE </span><span class="text_6">(6536)</span><span class="text_7">) so it falls through to the </span><span class="text_8">for </span><span class="text_7">loop, copies data out of the pipe </span><span class="text_6">(6563-6567)</span><span class="text_7">, and increments </span><span class="text_8">nread </span><span class="text_7">by the number of bytes copied. That many bytes are now available for writing, so </span><span class="text_8">piperead </span><span class="text_7">calls </span><span class="text_8">wakeup </span><span class="text_6">(6568) </span><span class="text_7">to wake any sleeping writers before it returns to its caller. </span><span class="text_8">Wakeup </span><span class="text_7">finds a process sleeping on </span><span class="text_8">&amp;p-&gt;nwrite</span><span class="text_7">, the process that was running </span><span class="text_8">pipewrite </span><span class="text_7">but stopped when the buffer filled. It marks that process as </span><span class="text_8">RUNNABLE</span><span class="text_7">.</span></p>
	<p class="block_80"><span class="text_2">The pipe code uses separate sleep channels for reader and writer ( </span><span class="text_3">p-&gt;nread </span><span class="text_2">and </span><span class="text_3">p-&gt;nwrite</span><span class="text_2">); this might make the system more efficient in the unlikely event that there are lots of readers and writers waiting for the same pipe. The pipe code sleeps inside a loop checking the sleep condition; if there are multiple readers or writers, all but the first process to wake up will see the condition is still false and sleep again.</span></p>
	<h3 class="block_90">Code: Wait, exit, and kill</h3>
	<p class="block_26"><span class="text_3">Sleep </span><span class="text_2">and </span><span class="text_3">wakeup </span><span class="text_2">can be used for many kinds of waiting. An interesting example, seen Chapter 0, is the </span><span class="text_3">wait </span><span class="text_2">system call that a parent process uses to wait for a child to exit. In xv6, when a child exits, it does not die immediately. Instead, it switches to the </span><span class="text_3">ZOMBIE </span><span class="text_2">process state until the parent calls </span><span class="text_3">wait </span><span class="text_2">to learn of the exit. The parent is then responsible for freeing the memory associated with the process and preparing the </span><span class="text_3">struct proc </span><span class="text_2">for reuse. If the parent exits before the child, the </span><span class="text_3">init </span><span class="text_2">process adopts the child and waits for it, so that every child has a parent to clean up after it. Keep in mind the possibility of races between parent and child </span><span class="text_3">wait </span><span class="text_2">and </span><span class="text_3">exit</span><span class="text_2">, as well as </span><span class="text_3">exit </span><span class="text_2">and </span><span class="text_3">exit</span><span class="text_2">.</span></p>
	<p class="block_18"><span class="text_8">Wait </span><span class="text_7">begins by acquiring </span><span class="text_8">ptable.lock</span><span class="text_7">. Then it scans the process table looking for children. If </span><span class="text_8">wait </span><span class="text_7">finds that the current process has children but that none have exited, it calls </span><span class="text_8">sleep </span><span class="text_7">to wait for one of them to exit </span><span class="text_6">(2689) </span><span class="text_7">and scans again. Here, the lock being released in </span><span class="text_8">sleep </span><span class="text_7">is </span><span class="text_8">ptable.lock</span><span class="text_7">, the special case we saw above.</span></p>
	<p class="block_122"><span class="text_8">Exit </span><span class="text_7">acquires </span><span class="text_8">ptable.lock </span><span class="text_7">and then wakes up any process sleeping on a wait channel equal to the current process’s parent </span><span class="text_8">proc </span><span class="text_6">(2628)</span><span class="text_7">; if there is such a process, it will be the parent in </span><span class="text_8">wait</span><span class="text_7">. This may look premature, since </span><span class="text_8">exit </span><span class="text_7">has not marked the current process as a </span><span class="text_8">ZOMBIE </span><span class="text_7">yet, but it is safe: although </span><span class="text_8">wakeup </span><span class="text_7">may mark the parent as </span><span class="text_8">RUNNABLE</span><span class="text_7">, the loop in </span><span class="text_8">wait </span><span class="text_7">cannot run until </span><span class="text_8">exit </span><span class="text_7">releases </span><span class="text_8">ptable.lock </span><span class="text_7">by calling </span><span class="text_8">sched </span><span class="text_7">to enter the scheduler, so </span><span class="text_8">wait </span><span class="text_7">can’t look at the exiting process until after </span><span class="text_8">exit </span><span class="text_7">has set its state to </span><span class="text_8">ZOMBIE </span><span class="text_6">(2640)</span><span class="text_7">. Before exit reschedules, it reparents all of the exiting process’s children, passing them to the </span><span class="text_8">initproc </span><span class="text_6">(2630-2637)</span><span class="text_7">. Finally, </span><span class="text_8">exit </span><span class="text_7">calls </span><span class="text_8">sched </span><span class="text_7">to relinquish the CPU.</span></p>
	<p class="block_18"><span class="text_7">If the parent process was sleeping in </span><span class="text_8">wait</span><span class="text_7">, the scheduler will eventually run it. The call to </span><span class="text_8">sleep </span><span class="text_7">returns holding </span><span class="text_8">ptable.lock</span><span class="text_7">; </span><span class="text_8">wait </span><span class="text_7">rescans the process table and finds the exited child with </span><span class="text_8">state == ZOMBIE</span><span class="text_7">. </span><span class="text_6">(2634)</span><span class="text_7">. It records the child’s </span><span class="text_8">pid </span><span class="text_7">and then cleans up the </span><span class="text_8">struct proc</span><span class="text_7">, freeing the memory associated with the process </span><span class="text_6">(2668-2676)</span><span class="text_7">.</span></p>
	<p class="block_15"><span class="text_2">The child process could have done most of the cleanup during </span><span class="text_3">exit</span><span class="text_2">, but it is important that the parent process be the one to free </span><span class="text_3">p-&gt;kstack </span><span class="text_2">and </span><span class="text_3">p-&gt;pgdir</span><span class="text_2">: when the child runs </span><span class="text_3">exit</span><span class="text_2">, its stack sits in the memory allocated as </span><span class="text_3">p-&gt;kstack </span><span class="text_2">and it uses its own pagetable. They can only be freed after the child process has finished running for the last time by calling </span><span class="text_3">swtch </span><span class="text_2">(via </span><span class="text_3">sched</span><span class="text_2">). This is one reason that the scheduler procedure runs on its own stack rather than on the stack of the thread that called </span><span class="text_3">sched</span><span class="text_2">.</span></p>
	<p class="block_18"><span class="text_7">While </span><span class="text_8">exit </span><span class="text_7">allows a process to terminate itself, </span><span class="text_8">kill </span><span class="text_6">(2875) </span><span class="text_7">lets one process request that another be terminated. It would be too complex for </span><span class="text_8">kill </span><span class="text_7">to directly destroy the victim process, since the victim might be executing on another CPU or sleeping while midway through updating kernel data structures. To address these challenges, </span><span class="text_8">kill </span><span class="text_7">does very little: it just sets the victim’s </span><span class="text_8">p-&gt;killed </span><span class="text_7">and, if it is sleeping, wakes it up. Eventually the victim will enter or leave the kernel, at which point code in </span><span class="text_8">trap </span><span class="text_7">will call </span><span class="text_8">exit </span><span class="text_7">if </span><span class="text_8">p-&gt;killed </span><span class="text_7">is set. If the victim is running in user space, it will soon enter the kernel by making a system call or because the timer (or some other device) interrupts.</span></p>
	<p class="block_18"><span class="text_7">If the victim process is in </span><span class="text_8">sleep</span><span class="text_7">, the call to </span><span class="text_8">wakeup </span><span class="text_7">will cause the victim process to return from </span><span class="text_8">sleep</span><span class="text_7">. This is potentially dangerous because the condition being waiting for may not be true. However, xv6 calls to </span><span class="text_8">sleep </span><span class="text_7">are always wrapped in a </span><span class="text_8">while </span><span class="text_7">loop that re-tests the condition after </span><span class="text_8">sleep </span><span class="text_7">returns. Some calls to </span><span class="text_8">sleep </span><span class="text_7">also test </span><span class="text_8">p&gt;killed </span><span class="text_7">in the loop, and abandon the current activity if it is set. This is only done when such abandonment would be correct. For example, the pipe read and write code </span><span class="text_6">(6537) </span><span class="text_7">returns if the killed flag is set; eventually the code will return back to trap, which will again check the flag and exit.</span></p>
	<p class="block_149"><span class="text_7">Some xv6 </span><span class="text_8">sleep </span><span class="text_7">loops do not check </span><span class="text_8">p-&gt;killed </span><span class="text_7">because the code is in the middle of a multi-step system call that should be atomic. The IDE driver </span><span class="text_6">(4279) </span><span class="text_7">is an example: it does not check </span><span class="text_8">p-&gt;killed </span><span class="text_7">because a disk operation may be one of a set of writes that are all needed in order for the file system to be left in a correct state. To avoid the complication of cleaning up after a partial operation, xv6 delays the killing of a process that is in the IDE driver until some point later when it is easy to kill the process (e.g., when the complete file system operation has completed and the process is about to return to user space).</span></p>
	<h3 class="block_17">Real world</h3>
	<p class="block_15"><span class="text_2">The xv6 scheduler implements a simple scheduling policy, which runs each process in turn. This policy is called </span><span class="text_3">round robin</span><span class="text_2">. Real operating systems implement more sophisticated policies that, for example, allow processes to have priorities. The idea is that a runnable high-priority process will be preferred by the scheduler over a runnable low-priority thread. These policies can become complex quickly because there are often competing goals: for example, the operating might also want to guarantee fairness and high-throughput. In addition, complex policies may lead to unintended interactions such as </span><span class="text_3">priority inversion </span><span class="text_2">and </span><span class="text_3">convoys</span><span class="text_2">. Priority inversion can happen when a low-priority and high-priority process share a lock, which when acquired by the low-priority process can cause the high-priority process to not run. A long convoy can form when many high-priority processes are waiting for a low-priority process that acquires a shared lock; once a convoy has formed they can persist for long period of time. To avoid these kinds of problems additional mechanisms are necessary in sophisticated schedulers.</span></p>
	<p class="block_15"><span class="text_3">Sleep </span><span class="text_2">and </span><span class="text_3">wakeup </span><span class="text_2">are a simple and effective synchronization method, but there are many others. The first challenge in all of them is to avoid the ‘‘missed wakeups’’ problem we saw at the beginning of the chapter. The original Unix kernel’s </span><span class="text_3">sleep </span><span class="text_2">simply disabled interrupts, which sufficed because Unix ran on a single-CPU system. Because xv6 runs on multiprocessors, it adds an explicit lock to </span><span class="text_3">sleep</span><span class="text_2">. FreeBSD’s </span><span class="text_3">msleep </span><span class="text_2">takes the same approach. Plan 9’s </span><span class="text_3">sleep </span><span class="text_2">uses a callback function that runs with the scheduling lock held just before going to sleep; the function serves as a last minute check of the sleep condition, to avoid missed wakeups. The Linux kernel’s </span><span class="text_3">sleep </span><span class="text_2">uses an explicit process queue instead of a wait channel; the queue has its own internal lock.</span></p>
	<p class="block_15"><span class="text_2">Scanning the entire process list in </span><span class="text_3">wakeup </span><span class="text_2">for processes with a matching </span><span class="text_3">chan </span><span class="text_2">is inefficient. A better solution is to replace the </span><span class="text_3">chan </span><span class="text_2">in both </span><span class="text_3">sleep </span><span class="text_2">and </span><span class="text_3">wakeup </span><span class="text_2">with a data structure that holds a list of processes sleeping on that structure. Plan 9’s </span><span class="text_3">sleep </span><span class="text_2">and </span><span class="text_3">wakeup </span><span class="text_2">call that structure a rendezvous point or </span><span class="text_3">Rendez</span><span class="text_2">. Many thread libraries refer to the same structure as a condition variable; in that context, the operations </span><span class="text_3">sleep </span><span class="text_2">and </span><span class="text_3">wakeup </span><span class="text_2">are called </span><span class="text_3">wait </span><span class="text_2">and </span><span class="text_3">signal</span><span class="text_2">. All of these mechanisms share the same flavor: the sleep condition is protected by some kind of lock dropped atomically during sleep.</span></p>
	<p class="block_15"><span class="text_2">The implementation of </span><span class="text_3">wakeup </span><span class="text_2">wakes up all processes that are waiting on a particular channel, and it might be the case that many processes are waiting for that particular channel. The operating system will schedule all these processes and they will race to check the sleep condition. Processes that behave in this way are sometimes called a </span><span class="text_3">thundering herd</span><span class="text_2">, and it is best avoided. Most condition variables have two primitives for </span><span class="text_3">wakeup</span><span class="text_2">: </span><span class="text_3">signal</span><span class="text_2">, which wakes up one process, and </span><span class="text_3">broadcast</span><span class="text_2">, which wakes up all processes waiting.</span></p>
	<p class="block_14">Semaphores are another common coordination mechanism. A semaphore is an integer value with two operations, increment and decrement (or up and down). It is aways possible to increment a semaphore, but the semaphore value is not allowed to drop below zero: a decrement of a zero semaphore sleeps until another process increments the semaphore, and then those two operations cancel out. The integer value typically corresponds to a real count, such as the number of bytes available in a pipe buffer or the number of zombie children that a process has. Using an explicit count as part of the abstraction avoids the ‘‘missed wakeup’’ problem: there is an explicit count of the number of wakeups that have occurred. The count also avoids the spurious wakeup and thundering herd problems.</p>
	<p class="block_15"><span class="text_2">Terminating processes and cleaning them up introduces much complexity in xv6. In most operating systems it is even more complex, because, for example, the victim process may be deep inside the kernel sleeping, and unwinding its stack requires much careful programming. Many operating system unwind the stack using explicit mechanisms for exception handling, such as </span><span class="text_3">longjmp</span><span class="text_2">. Furthermore, there are other events that can cause a sleeping process to be woken up, even though the events it is waiting for has not happened yet. For example, when a process is sleeping, another process may send a </span><span class="text_3">signal </span><span class="text_2">to it. In this case, the process will return from the interrupted system call with the value -1 and with the error code set to EINTR. The application can check for these values and decide what to do. Xv6 doesn’t support signals and this complexity doesn’t arise.</span></p>
	<p class="block_125"><span class="text_2">Xv6’s support for </span><span class="text_3">kill </span><span class="text_2">is not entirely satisfactory: there are sleep loops which probably should check for </span><span class="text_3">p-&gt;killed</span><span class="text_2">. A related problem is that, even for </span><span class="text_3">sleep </span><span class="text_2">loops that check </span><span class="text_3">p-&gt;killed</span><span class="text_2">, there is a race between </span><span class="text_3">sleep </span><span class="text_2">and </span><span class="text_3">kill</span><span class="text_2">; the latter may set </span><span class="text_3">p&gt;killed </span><span class="text_2">and try to wake up the victim just after the victim’s loop checks </span><span class="text_3">p-&gt;killed </span><span class="text_2">but before it calls </span><span class="text_3">sleep</span><span class="text_2">. If this problem occurs, the victim won’t notice the </span><span class="text_3">p&gt;killed </span><span class="text_2">until the condition it is waiting for occurs. This may be quite a bit later (e.g., when the IDE driver returns a disk block that the victim is waiting for) or never (e.g., if the victim is waiting from input from the console, but the user doesn’t type any input).</span></p>
	<h3 class="block_177">Exercises</h3>
	<ol class="list_">
	<li class="block_178"><span class="text_4">Sleep has to check lk != &amp;ptable.lock to avoid a deadlock </span><span class="text_5">(2817-2820)</span><span class="text_4">. It could eliminate the special case by replacing</span></li>
</ol>
	<p class="block_179">if(lk != &amp;ptable.lock){ acquire(&amp;ptable.lock); release(lk);</p>
	<p class="block_180"><span class="text_30">} </span><span class="text_7">with</span></p>
	<p class="block_181">release(lk); acquire(&amp;ptable.lock);</p>
	<p class="block_182"><span class="text_2">Doing this would break </span><span class="text_3">sleep</span><span class="text_2">. How?</span></p>
	<ol class="list_">
	<li value="2" class="block_183"><span class="text_2">Most process cleanup could be done by either </span><span class="text_3">exit </span><span class="text_2">or </span><span class="text_3">wait</span><span class="text_2">, but we saw above that </span><span class="text_3">exit </span><span class="text_2">must not free </span><span class="text_3">p-&gt;stack</span><span class="text_2">. It turns out that </span><span class="text_3">exit </span><span class="text_2">must be the one to close the open files. Why? The answer involves pipes.</span></li>
	<li class="block_128">Implement semaphores in xv6. You can use mutexes but do not use sleep andwakeup. Replace the uses of sleep and wakeup in xv6 with semaphores. Judge the result.</li>
	<li class="block_91"><span class="text_2">Fix the race mentioned above between </span><span class="text_3">kill </span><span class="text_2">and </span><span class="text_3">sleep</span><span class="text_2">, so that a </span><span class="text_3">kill </span><span class="text_2">that occurs after the victim’s sleep loop checks </span><span class="text_3">p-&gt;killed </span><span class="text_2">but before it calls </span><span class="text_3">sleep </span><span class="text_2">results in the victim abandoning the current system call.</span></li>
	<li class="block_92"><span class="text_2">Design a plan so that every sleep loop checks </span><span class="text_3">p-&gt;killed </span><span class="text_2">so that, for example, a process that is in the IDE driver can return quickly from the while loop if another kills that process.<br class="calibre12" id="calibre_pb_9"/>
</span></li>
</ol>
	</body></html>
