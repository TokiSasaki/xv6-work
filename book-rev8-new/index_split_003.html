<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
    <title>xv6 - DRAFT as of September 3, 2014</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<p class="block_12" id="calibre_pb_5">Chapter 0</p>
	<h1 id="id_Toc460887574" class="block_13">Operating system interfaces</h1>
	<p class="paragraph01">The job of an operating system is to share a computer among multiple programs and to provide a more useful set of services than the hardware alone supports. The operating system manages and abstracts the low-level hardware, so that, for example, a word processor need not concern itself with which type of disk hardware is being used. It also multiplexes the hardware, allowing many programs to share the computer and run (or appear to run) at the same time. Finally, operating systems provide controlled ways for programs to interact, so that they can share data or work together.</p>
	<p class="paragraph01">An operating system provides services to user programs through an interface. Designing a good interface turns out to be difficult. On the one hand, we would like the interface to be simple and narrow because that makes it easier to get the implementation right. On the other hand, we may be tempted to offer many sophisticated features to applications. The trick in resolving this tension is to design interfaces that rely on a few mechanisms that can be combined to provide much generality.</p>
	<p class="paragraph01">This book uses a single operating system as a concrete example to illustrate operating system concepts. That operating system, xv6, provides the basic interfaces introduced by Ken Thompson and Dennis Ritchie’s Unix operating system, as well as mimicking Unix’s internal design. Unix provides a narrow interface whose mechanisms combine well, offering a surprising degree of generality. This interface has been so successful that modern operating systems—BSD, Linux, Mac OS X, Solaris, and even, to a lesser extent, Microsoft Windows—have Unix-like interfaces. Understanding xv6 is a good start toward understanding any of these systems and many others.</p>
	<p class="paragraph01">As shown in Figure 0-1, xv6 takes the traditional form of a <span class="text_3">kernel</span>, a special program that provides services to running programs. Each running program, called a <span class="text_3">process</span>, has memory containing instructions, data, and a stack. The instructions implement the program’s computation. The data are the variables on which the computation acts. The stack organizes the program’s procedure calls.</p>
	<p class="paragraph01">When a process needs to invoke a kernel service, it invokes a procedure call in the operating system interface. Such a procedure is called a <span class="text_3">system call</span>. The system call enters the kernel; the kernel performs the service and returns. Thus a process alternates between executing in <span class="text_3">user space</span> and <span class="text_3">kernel space</span>.</p>
	<p class="paragraph01">The kernel uses the CPU’s hardware protection mechanisms to ensure that each process executing in user space can access only its own memory. The kernel executes with the hardware privileges required to implement these protections; user programs execute without those privileges. When a user program invokes a system call, the hardware raises the privilege level and starts executing a pre-arranged function in the kernel.</p>
	<p class="paragraph01">The collection of system calls that a kernel provides is the interface that user programs see. The xv6 kernel provides a subset of the services and system calls that Unix kernels traditionally offer. Figure 0-2 lists all xv6’s system calls.</p>
	<p class="paragraph01">The rest of this chapter outlines xv6’s services—processes, memory, file descriptors, pipes, and file system—and illustrates them with code snippets and discussions of how the shell uses them. The shell’s use of system calls illustrates how carefully they have been designed.</p>
	<p class="paragraph01">The shell is an ordinary program that reads commands from the user and executes them, and is the primary user interface to traditional Unix-like systems. The fact that the shell is a user program, not part of the kernel, illustrates the power of the system call interface: there is nothing special about the shell. It also means that the shell is easy to replace; as a result, modern Unix systems have a variety of shells to choose from, each with its own user interface and scripting features. The xv6 shell is a simple implementation of the essence of the Unix Bourne shell. Its implementation can be found at line <span class="text_5">(8350)</span>.</p>
	<h3 class="block_17">Processes and memory</h3>
	<p class="paragraph01">An xv6 process consists of user-space memory (instructions, data, and stack) and per-process state private to the kernel. Xv6 can <span class="text_8">time-share</span> processes: it transparently switches the available CPUs among the set of processes waiting to execute. When a process is not executing, xv6 saves its CPU registers, restoring them when it next runs the process. The kernel associates a process identifier, or <span class="text_8">pid</span>, with each process.</p>

<img alt="Image" src="images/figure0-1.png" class="calibre7"/>
<p class="block_20"><b>Figure 0-1.</b> A kernel and two user processes.</p>

<p class="paragraph01">A process may create a new process using the <span class="text_3">fork</span> system call. <span class="text_3">Fork</span> creates a new process, called the <span class="text_3">child process</span>, with exactly the same memory contents as the calling process, called the <span class="text_3">parent process</span>. <span class="text_3">Fork </span>returns in both the parent and the child. In the parent, <span class="text_3">fork</span> returns the child’s pid; in the child, it returns zero. For example, consider the following program fragment:></p>
<p class="block_22"><pre><code>
	int pid = fork();
	if(pid &gt; 0){ printf("parent: child=%d\n", pid);
		pid = wait();
		printf("child %d is done\n", pid);
	}
	else if(pid == 0){
		printf("child: exiting\n");
		exit();
	}
	else {
		printf("fork error\n");
	}
</code></pre></p>
<p class="block_26">The <span class="text_3">exit</span> system call causes the calling process to stop executing and to release resources such as memory and open files. The <span class="text_3">wait</span> system call returns the pid of an exited child of the current process; if none of the caller’s children has exited, </span><span class="text_3">wait </span><span class="text_2">waits for one to do so. In the example, the output lines</span></p>
	<p class="block_27"><span class="text_12"></span><span class="text_13">System call<span class="tab">       </span>Description</span></p>
	<p class="block_28"><span class="text_12"></span><span class="text_12">fork()<span class="tab">       </span>Create process</span></p>
	<p class="block_29">exit()<span class="tab">       </span>Terminate current process wait()<span class="tab">       </span>Wait for a child process to exit kill(pid)<span class="tab">       </span>Terminate process pid getpid()<span class="tab">       </span>Return current process’s id</p>
	<p class="block_28"><span class="text_12"></span><span class="text_12">sleep(n)<span class="tab">       </span>Sleep for n seconds</span></p>
	<p class="block_28"><span class="text_12"></span><span class="text_12">exec(filename, *argv)<span class="tab">       </span>Load a file and execute it</span></p>
	<p class="block_28"><span class="text_12"></span><span class="text_12">sbrk(n)<span class="tab">       </span>Grow process’s memory by </span><span class="text_12">n bytes</span></p>
	<p class="block_30">open(filename, flags)<span class="tab">       </span>Open a file; flags indicate read/write read(fd, buf, n)<span class="tab">       </span>Read n byes from an open file into buf write(fd, buf, n)<span class="tab">       </span>Write n bytes to an open file</p>
	<p class="block_31">close(fd)<span class="tab">       </span>Release open file fd dup(fd)<span class="tab">       </span>Duplicate fd</p>
	<p class="block_30">pipe(p)<span class="tab">       </span>Create a pipe and return fd’s in p chdir(dirname)<span class="tab">       </span>Change the current directory</p>
	<p class="block_32">mkdir(dirname)<span class="tab">       </span>Create a new directory mknod(name, major, minor)<span class="tab">       </span>Create a device file</p>
	<p class="block_30">fstat(fd)<span class="tab">       </span>Return info about an open file link(f1, f2)<span class="tab">       </span>Create another name (f2) for the file f1</p>
	<p class="block_28"><span class="text_12"></span><span class="text_12">unlink(filename)<span class="tab">       </span>Remove a file</span></p>
	<p class="block_33"><span class="text_12"></span><span class="text_13">Figure 0-2</span><span class="text_12">. Xv6 system calls</span></p>
	<p class="block_35">parent: child=1234 child: exiting</p>
	<p class="block_36"><span class="text_2">might come out in either order, depending on whether the parent or child gets to its </span><span class="text_3">printf </span><span class="text_2">call first. After the child exits the parent’s </span><span class="text_3">wait </span><span class="text_2">returns, causing the parent to print</span></p>
	<p class="block_37">parent: child 1234 is done</p>
	<p class="block_11">Note that the parent and child were executing with different memory and different registers: changing a variable in one does not affect the other.</p>
	<p class="paragraph01"><span class="text_2">The </span><span class="text_3">exec </span><span class="text_2">system call replaces the calling process’s memory with a new memory image loaded from a file stored in the file system. The file must have a particular format, which specifies which part of the file holds instructions, which part is data, at which instruction to start, etc. xv6 uses the ELF format, which Chapter 2 discusses in more detail. When </span><span class="text_3">exec </span><span class="text_2">succeeds, it does not return to the calling program; instead, the instructions loaded from the file start executing at the entry point declared in the ELF header. </span><span class="text_3">Exec </span><span class="text_2">takes two arguments: the name of the file containing the executable and an array of string arguments. For example:</span></p>
	<p class="block_38">char *argv[3];</p>
	<p class="block_39">argv[0] = "echo"; argv[1] = "hello"; argv[2] = 0; exec("/bin/echo", argv); printf("exec error\n");</p>
	<p class="block_26"><span class="text_2">This fragment replaces the calling program with an instance of the program </span><span class="text_3">/bin/echo </span><span class="text_2">running with the argument list </span><span class="text_3">echo hello</span><span class="text_2">. Most programs ignore the first argument, which is conventionally the name of the program.</span></p>
	<p class="paragraph01"><span class="text_7">The xv6 shell uses the above calls to run programs on behalf of users. The main structure of the shell is simple; see </span><span class="text_8">main </span><span class="text_6">(8501)</span><span class="text_7">. The main loop reads the input on the command line using </span><span class="text_8">getcmd</span><span class="text_7">. Then it calls </span><span class="text_8">fork</span><span class="text_7">, which creates a copy of the shell process. The parent shell calls </span><span class="text_8">wait</span><span class="text_7">, while the child process runs the command. For example, if the user had typed ‘‘</span><span class="text_8">echo hello</span><span class="text_7">’’ at the prompt, </span><span class="text_8">runcmd </span><span class="text_7">would have been called with ‘‘</span><span class="text_8">echo hello</span><span class="text_7">’’ as the argument. </span><span class="text_8">runcmd </span><span class="text_6">(8406) </span><span class="text_7">runs the actual command. For ‘‘</span><span class="text_8">echo hello</span><span class="text_7">’’, it would call </span><span class="text_8">exec </span><span class="text_6">(8426)</span><span class="text_7">. If </span><span class="text_8">exec </span><span class="text_7">succeeds then the child will execute instructions from </span><span class="text_8">echo </span><span class="text_7">instead of </span><span class="text_8">runcmd</span><span class="text_7">. At some point </span><span class="text_8">echo </span><span class="text_7">will call </span><span class="text_8">exit</span><span class="text_7">, which will cause the parent to return from </span><span class="text_8">wait </span><span class="text_7">in </span><span class="text_8">main </span><span class="text_6">(8501)</span><span class="text_7">. You might wonder why </span><span class="text_8">fork </span><span class="text_7">and </span><span class="text_8">exec </span><span class="text_7">are not combined in a single call; we will see later that separate calls for creating a process and loading a program is a clever design.</span></p>
	<p class="paragraph01"><span class="text_2">Xv6 allocates most user-space memory implicitly: </span><span class="text_3">fork </span><span class="text_2">allocates the memory required for the child’s copy of the parent’s memory, and </span><span class="text_3">exec </span><span class="text_2">allocates enough memory to hold the executable file. A process that needs more memory at run-time (perhaps for </span><span class="text_3">malloc</span><span class="text_2">) can call </span><span class="text_3">sbrk(n) </span><span class="text_2">to grow its data memory by </span><span class="text_3">n </span><span class="text_2">bytes; </span><span class="text_3">sbrk </span><span class="text_2">returns the location of the new memory.</span></p>
	<p class="block_40">Xv6 does not provide a notion of users or of protecting one user from another; in Unix terms, all xv6 processes run as root.</p>
	<h3 class="block_41">I/O and File descriptors</h3>
	<p class="paragraph01"><span class="text_2">A </span><span class="text_3">file descriptor </span><span class="text_2">is a small integer representing a kernel-managed object that a process may read from or write to. A process may obtain a file descriptor by opening a file, directory, or device, or by creating a pipe, or by duplicating an existing descriptor. For simplicity we’ll often refer to the object a file descriptor refers to as a ‘‘file’’; the file descriptor interface abstracts away the differences between files, pipes, and devices, making them all look like streams of bytes.</span></p>
	<p class="block_42"><span class="text_4">Internally, the xv6 kernel uses the file descriptor as an index into a per-process table, so that every process has a private space of file descriptors starting at zero. By convention, a process reads from file descriptor 0 (standard input), writes output to file descriptor 1 (standard output), and writes error messages to file descriptor 2 (standard error). As we will see, the shell exploits the convention to implement I/O redirection and pipelines. The shell ensures that it always has three file descriptors open </span><span class="text_5">(8507)</span><span class="text_4">, which are by default file descriptors for the console.</span></p>
	<p class="paragraph01"><span class="text_2">The </span><span class="text_3">read </span><span class="text_2">and </span><span class="text_3">write </span><span class="text_2">system calls read bytes from and write bytes to open files named by file descriptors. The call </span><span class="text_3">read(fd, buf, n) </span><span class="text_2">reads at most </span><span class="text_3">n </span><span class="text_2">bytes from the file descriptor </span><span class="text_3">fd</span><span class="text_2">, copies them into </span><span class="text_3">buf</span><span class="text_2">, and returns the number of bytes read. Each file descriptor that refers to a file has an offset associated with it. </span><span class="text_3">Read </span><span class="text_2">reads data from the current file offset and then advances that offset by the number of bytes read: a subsequent </span><span class="text_3">read </span><span class="text_2">will return the bytes following the ones returned by the first </span><span class="text_3">read</span><span class="text_2">. When there are no more bytes to read, </span><span class="text_3">read </span><span class="text_2">returns zero to signal the end of the file.</span></p>
	<p class="paragraph01"><span class="text_2">The call </span><span class="text_3">write(fd, buf, n) </span><span class="text_2">writes </span><span class="text_3">n </span><span class="text_2">bytes from </span><span class="text_3">buf </span><span class="text_2">to the file descriptor </span><span class="text_3">fd </span><span class="text_2">and returns the number of bytes written. Fewer than </span><span class="text_3">n </span><span class="text_2">bytes are written only when an error occurs. Like </span><span class="text_3">read</span><span class="text_2">, </span><span class="text_3">write </span><span class="text_2">writes data at the current file offset and then advances that offset by the number of bytes written: each </span><span class="text_3">write </span><span class="text_2">picks up where the previous one left off.</span></p>
	<p class="block_43"><span class="text_2">The following program fragment (which forms the essence of </span><span class="text_3">cat</span><span class="text_2">) copies data from its standard input to its standard output. If an error occurs, it writes a message to the standard error.</span></p>
	<p class="block_44">char buf[512]; int n;</p>
	<p class="block_45">for(;;){ n = read(0, buf, sizeof buf); if(n == 0) break;</p>
	<p class="block_46">if(n &lt; 0){ fprintf(2, "read error\n"); exit();</p>
	<p class="block_47">} if(write(1, buf, n) != n){ fprintf(2, "write error\n"); exit();</p>
	<p class="block_48">}</p>
	<p class="block_25">}</p>
	<p class="block_26"><span class="text_2">The important thing to note in the code fragment is that </span><span class="text_3">cat </span><span class="text_2">doesn’t know whether it is reading from a file, console, or a pipe. Similarly </span><span class="text_3">cat </span><span class="text_2">doesn’t know whether it is printing to a console, a file, or whatever. The use of file descriptors and the convention that file descriptor 0 is input and file descriptor 1 is output allows a simple implementation of </span><span class="text_3">cat</span><span class="text_2">.</span></p>
	<p class="paragraph01"><span class="text_2">The </span><span class="text_3">close </span><span class="text_2">system call releases a file descriptor, making it free for reuse by a future </span><span class="text_3">open</span><span class="text_2">, </span><span class="text_3">pipe</span><span class="text_2">, or </span><span class="text_3">dup </span><span class="text_2">system call (see below). A newly allocated file descriptor is always the lowest-numbered unused descriptor of the current process.</span></p>
	<p class="paragraph01"><span class="text_2">File descriptors and </span><span class="text_3">fork </span><span class="text_2">interact to make I/O redirection easy to implement. </span><span class="text_3">Fork </span><span class="text_2">copies the parent’s file descriptor table along with its memory, so that the child starts with exactly the same open files as the parent. The system call </span><span class="text_3">exec </span><span class="text_2">replaces the calling process’s memory but preserves its file table. This behavior allows the shell to implement I/O redirection by forking, reopening chosen file descriptors, and then execing the new program. Here is a simplified version of the code a shell runs for the command </span><span class="text_3">cat &lt;input.txt</span><span class="text_2">:</span></p>
	<p class="block_38">char *argv[2];</p>
	<p class="block_49">argv[0] = "cat"; argv[1] = 0; if(fork() == 0) { close(0); open("input.txt", O_RDONLY); exec("cat", argv);</p>
	<p class="block_25">}</p>
	<p class="block_26"><span class="text_2">After the child closes file descriptor 0, </span><span class="text_3">open </span><span class="text_2">is guaranteed to use that file descriptor for the newly opened </span><span class="text_3">input.txt</span><span class="text_2">: 0 will be the smallest available file descriptor. </span><span class="text_3">Cat </span><span class="text_2">then executes with file descriptor 0 (standard input) referring to </span><span class="text_3">input.txt</span><span class="text_2">.</span></p>
	<p class="paragraph01"><span class="text_7">The code for I/O redirection in the xv6 shell works in exactly this way </span><span class="text_6">(8430)</span><span class="text_7">. Recall that at this point in the code the shell has already forked the child shell and that </span><span class="text_8">runcmd </span><span class="text_7">will call </span><span class="text_8">exec </span><span class="text_7">to load the new program. Now it should be clear why it is a good idea that </span><span class="text_8">fork </span><span class="text_7">and </span><span class="text_8">exec </span><span class="text_7">are separate calls. This separation allows the shell to fix up the child process before the child runs the intended program.</span></p>
	<p class="block_43"><span class="text_2">Although </span><span class="text_3">fork </span><span class="text_2">copies the file descriptor table, each underlying file offset is shared between parent and child. Consider this example:</span></p>
	<p class="block_50">if(fork() == 0) { write(1, "hello ", 6); exit();</p>
	<p class="block_51">} else { wait(); write(1, "world\n", 6);</p>
	<p class="block_37">}</p>
	<p class="block_26"><span class="text_2">At the end of this fragment, the file attached to file descriptor 1 will contain the data </span><span class="text_3">hello world</span><span class="text_2">. The </span><span class="text_3">write </span><span class="text_2">in the parent (which, thanks to </span><span class="text_3">wait</span><span class="text_2">, runs only after the child is done) picks up where the child’s </span><span class="text_3">write </span><span class="text_2">left off. This behavior helps produce sequential output from sequences of shell commands, like </span><span class="text_3">(echo hello; echo world)</span></p>
	<p class="block_52"><span class="text_3">&gt;output.txt</span><span class="text_2">.</span></p>
	<p class="block_53"><span class="text_2">The </span><span class="text_3">dup </span><span class="text_2">system call duplicates an existing file descriptor, returning a new one that refers to the same underlying I/O object. Both file descriptors share an offset, just as the file descriptors duplicated by </span><span class="text_3">fork </span><span class="text_2">do. This is another way to write </span><span class="text_3">hello world </span><span class="text_2">into a file:</span></p>
	<p class="block_54">fd = dup(1); write(1, "hello ", 6); write(fd, "world\n", 6);</p>
	<p class="paragraph01"><span class="text_2">Two file descriptors share an offset if they were derived from the same original file descriptor by a sequence of </span><span class="text_3">fork </span><span class="text_2">and </span><span class="text_3">dup </span><span class="text_2">calls. Otherwise file descriptors do not share offsets, even if they resulted from </span><span class="text_3">open </span><span class="text_2">calls for the same file. </span><span class="text_3">Dup </span><span class="text_2">allows shells to implement commands like this: </span><span class="text_3">ls existing-file non-existing-file &gt; tmp1 2&gt;&amp;1</span><span class="text_2">. The </span><span class="text_3">2&gt;&amp;1 </span><span class="text_2">tells the shell to give the command a file descriptor 2 that is a duplicate of descriptor 1. Both the name of the existing file and the error message for the non-existing file will show up in the file </span><span class="text_3">tmp1. </span><span class="text_2">The xv6 shell doesn’t support I/O redirection for the error file descriptor, but now you know how to implement it.</span></p>
	<p class="block_55">File descriptors are a powerful abstraction, because they hide the details of what they are connected to: a process writing to file descriptor 1 may be writing to a file, to a device like the console, or to a pipe.</p>
	<h3 class="block_56">Pipes</h3>
	<p class="paragraph01"><span class="text_2">A </span><span class="text_3">pipe </span><span class="text_2">is a small kernel buffer exposed to processes as a pair of file descriptors, one for reading and one for writing. Writing data to one end of the pipe makes that data available for reading from the other end of the pipe. Pipes provide a way for processes to communicate.</span></p>
	<p class="block_43"><span class="text_2">The following example code runs the program </span><span class="text_3">wc </span><span class="text_2">with standard input connected to the read end of a pipe.</span></p>
	<p class="block_57">int p[2]; char *argv[2];</p>
	<p class="block_58">argv[0] = "wc"; argv[1] = 0;</p>
	<p class="block_59">pipe(p); if(fork() == 0) { close(0); dup(p[0]); close(p[0]); close(p[1]); exec("/bin/wc", argv);</p>
	<p class="block_60">} else { write(p[1], "hello world\n", 12); close(p[0]); close(p[1]);</p>
	<p class="block_25">}</p>
	<p class="block_26"><span class="text_2">The program calls </span><span class="text_3">pipe</span><span class="text_2">, which creates a new pipe and records the read and write file descriptors in the array </span><span class="text_3">p</span><span class="text_2">. After </span><span class="text_3">fork</span><span class="text_2">, both parent and child have file descriptors referring to the pipe. The child dups the read end onto file descriptor 0, closes the file descriptors in </span><span class="text_3">p</span><span class="text_2">, and execs </span><span class="text_3">wc</span><span class="text_2">. When </span><span class="text_3">wc </span><span class="text_2">reads from its standard input, it reads from the pipe. The parent writes to the write end of the pipe and then closes both of its file descriptors.</span></p>
	<p class="paragraph01"><span class="text_2">If no data is available, a </span><span class="text_3">read </span><span class="text_2">on a pipe waits for either data to be written or all file descriptors referring to the write end to be closed; in the latter case, </span><span class="text_3">read </span><span class="text_2">will return 0, just as if the end of a data file had been reached. The fact that </span><span class="text_3">read </span><span class="text_2">blocks until it is impossible for new data to arrive is one reason that it’s important for the child to close the write end of the pipe before executing </span><span class="text_3">wc </span><span class="text_2">above: if one of </span><span class="text_3">wc</span><span class="text_2">’s file descriptors referred to the write end of the pipe, </span><span class="text_3">wc </span><span class="text_2">would never see end-of-file.</span></p>
	<p class="block_61"><span class="text_7">The xv6 shell implements pipelines such as </span><span class="text_8">grep fork sh.c | wc -l </span><span class="text_7">in a manner similar to the above code </span><span class="text_6">(8450)</span><span class="text_7">. The child process creates a pipe to connect the left end of the pipeline with the right end. Then it calls </span><span class="text_8">runcmd </span><span class="text_7">for the left end of the pipeline and </span><span class="text_8">runcmd </span><span class="text_7">for the right end, and waits for the left and the right ends to finish, by calling </span><span class="text_8">wait </span><span class="text_7">twice. The right end of the pipeline may be a command that itself includes a pipe (e.g., </span><span class="text_8">a | b | c)</span><span class="text_7">, which itself forks two new child processes (one for </span><span class="text_8">b </span><span class="text_7">and one for </span><span class="text_8">c</span><span class="text_7">). Thus, the shell may create a tree of processes. The leaves of this tree are commands and the interior nodes are processes that wait until the left and right children complete. In principle, you could have the interior nodes run the left end of a pipeline, but doing so correctly would complicate the implementation. Pipes may seem no more powerful than temporary files: the pipeline</span></p>
	<p class="block_37">echo hello world | wc</p>
	<p class="block_62">could be implemented without pipes as</p>
	<p class="block_37">echo hello world &gt;/tmp/xyz; wc &lt;/tmp/xyz</p>
	<p class="block_63"><span class="text_2">There are at least three key differences between pipes and temporary files. First, pipes automatically clean themselves up; with the file redirection, a shell would have to be careful to remove </span><span class="text_3">/tmp/xyz </span><span class="text_2">when done. Second, pipes can pass arbitrarily long streams of data, while file redirection requires enough free space on disk to store all the data. Third, pipes allow for synchronization: two processes can use a pair of pipes to send messages back and forth to each other, with each </span><span class="text_3">read </span><span class="text_2">blocking its calling process until the other process has sent data with </span><span class="text_3">write</span><span class="text_2">.</span></p>
	<h3 class="block_17">File system</h3>
	<p class="block_53"><span class="text_2">The xv6 file system provides data files, which are uninterpreted byte arrays, and directories, which contain named references to data files and other directories. Xv6 implements directories as a special kind of file. The directories form a tree, starting at a special directory called the </span><span class="text_3">root</span><span class="text_2">. A </span><span class="text_3">path </span><span class="text_2">like </span><span class="text_3">/a/b/c </span><span class="text_2">refers to the file or directory named </span><span class="text_3">c </span><span class="text_2">inside the directory named </span><span class="text_3">b </span><span class="text_2">inside the directory named </span><span class="text_3">a </span><span class="text_2">in the root directory </span><span class="text_3">/</span><span class="text_2">. Paths that don’t begin with </span><span class="text_3">/ </span><span class="text_2">are evaluated relative to the calling process’s </span><span class="text_3">current directory</span><span class="text_2">, which can be changed with the </span><span class="text_3">chdir </span><span class="text_2">system call. Both these code fragments open the same file (assuming all the directories involved exist):</span></p>
	<p class="block_64">chdir("/a"); chdir("b"); open("c", O_RDONLY); open("/a/b/c", O_RDONLY);</p>
	<p class="block_26"><span class="text_2">The first fragment changes the process’s current directory to </span><span class="text_3">/a/b</span><span class="text_2">; the second neither refers to nor modifies the process’s current directory.</span></p>
	<p class="block_53"><span class="text_2">There are multiple system calls to create a new file or directory: </span><span class="text_3">mkdir </span><span class="text_2">creates a new directory, </span><span class="text_3">open </span><span class="text_2">with the </span><span class="text_3">O_CREATE </span><span class="text_2">flag creates a new data file, and </span><span class="text_3">mknod </span><span class="text_2">creates a new device file. This example illustrates all three:</span></p>
	<p class="block_65">mkdir("/dir"); fd = open("/dir/file", O_CREATE|O_WRONLY); close(fd);</p>
	<p class="block_25">mknod("/console", 1, 1);</p>
	<p class="block_26"><span class="text_3">Mknod </span><span class="text_2">creates a file in the file system, but the file has no contents. Instead, the file’s metadata marks it as a device file and records the major and minor device numbers (the two arguments to </span><span class="text_3">mknod</span><span class="text_2">), which uniquely identify a kernel device. When a process later opens the file, the kernel diverts </span><span class="text_3">read </span><span class="text_2">and </span><span class="text_3">write </span><span class="text_2">system calls to the kernel device implementation instead of passing them to the file system.</span></p>
	<p class="block_66"><span class="text_3">fstat </span><span class="text_2">retrieves information about the object a file descriptor refers to. It fills in a</span></p>
	<p class="block_67"><span class="text_3">struct stat</span><span class="text_2">, defined in </span><span class="text_3">stat.h </span><span class="text_2">as:</span></p>
	<p class="block_68">#define T_DIR 1 // Directory</p>
	<p class="block_69">#define T_FILE 2 // File #define T_DEV 3 // Device</p>
	<p class="block_70">struct stat { short type; // Type of file int dev; <span class="tab">       </span>// File system’s disk device uint ino; <span class="tab">       </span>// Inode number short nlink; // Number of links to file uint size; // Size of file in bytes</p>
	<p class="block_25">};</p>
	<p class="block_71"><span class="text_2">A file’s name is distinct from the file itself; the same underlying file, called an </span><span class="text_3">inode</span><span class="text_2">, can have multiple names, called </span><span class="text_3">links</span><span class="text_2">. The </span><span class="text_3">link </span><span class="text_2">system call creates another file system name referring to the same inode as an existing file. This fragment creates a new file named both </span><span class="text_3">a </span><span class="text_2">and </span><span class="text_3">b</span><span class="text_2">.</span></p>
	<p class="block_72">open("a", O_CREATE|O_WRONLY); link("a", "b");</p>
	<p class="block_26"><span class="text_2">Reading from or writing to </span><span class="text_3">a </span><span class="text_2">is the same as reading from or writing to </span><span class="text_3">b</span><span class="text_2">. Each inode is identified by a unique </span><span class="text_14">inode number</span><span class="text_2">. After the code sequence above, it is possible to determine that </span><span class="text_3">a </span><span class="text_2">and </span><span class="text_3">b </span><span class="text_2">refer to the same underlying contents by inspecting the result of </span><span class="text_3">fstat</span><span class="text_2">: both will return the same inode number (</span><span class="text_3">ino</span><span class="text_2">), and the </span><span class="text_3">nlink </span><span class="text_2">count will be set to 2.</span></p>
	<p class="block_43"><span class="text_2">The </span><span class="text_3">unlink </span><span class="text_2">system call removes a name from the file system. The file’s inode and the disk space holding its content are only freed when the file’s link count is zero and no file descriptors refer to it. Thus adding</span></p>
	<p class="block_25">unlink("a");</p>
	<p class="block_73"><span class="text_2">to the last code sequence leaves the inode and file content accessible as </span><span class="text_3">b</span><span class="text_2">. Furthermore,</span></p>
	<p class="block_74">fd = open("/tmp/xyz", O_CREATE|O_RDWR); unlink("/tmp/xyz");</p>
	<p class="block_26"><span class="text_2">is an idiomatic way to create a temporary inode that will be cleaned up when the process closes </span><span class="text_3">fd </span><span class="text_2">or exits.</span></p>
	<p class="paragraph01"><span class="text_2">Xv6 commands for file system operations are implemented as user-level programs such as </span><span class="text_3">mkdir</span><span class="text_2">, </span><span class="text_3">ln</span><span class="text_2">, </span><span class="text_3">rm</span><span class="text_2">, etc. This design allows anyone to extend the shell with new user commands. In hind-sight this plan seems obvious, but other systems designed at the time of Unix often built such commands into the shell (and built the shell into the kernel).</span></p>
	<p class="block_75"><span class="text_7">One exception is </span><span class="text_8">cd</span><span class="text_7">, which is built into the shell </span><span class="text_6">(8516)</span><span class="text_7">. </span><span class="text_8">cd </span><span class="text_7">must change the current working directory of the shell itself. If </span><span class="text_8">cd </span><span class="text_7">were run as a regular command, then the shell would fork a child process, the child process would run </span><span class="text_8">cd</span><span class="text_7">, and </span><span class="text_8">cd </span><span class="text_7">would change the </span><span class="text_15">child</span><span class="text_7">’s working directory. The parent’s (i.e., the shell’s) working directory would not change.</span></p>
	<h3 class="block_17">Real world</h3>
	<p class="paragraph01">Unix’s combination of the ‘‘standard’’ file descriptors, pipes, and convenient shell syntax for operations on them was a major advance in writing general-purpose reusable programs. The idea sparked a whole culture of ‘‘software tools’’ that was responsible for much of Unix’s power and popularity, and the shell was the first so-called ‘‘scripting language.’’ The Unix system call interface persists today in systems like BSD, Linux, and Mac OS X.</p>
	<p class="paragraph01"><span class="text_2">Modern kernels provide many more system calls, and many more kinds of kernel services, than xv6. For the most part, modern Unix-derived operating systems have not followed the early Unix model of exposing devices as special files, like the </span><span class="text_3">console </span><span class="text_2">device file discussed above. The authors of Unix went on to build Plan 9, which applied the ‘‘resources are files’’ concept to modern facilities, representing networks, graphics, and other resources as files or file trees.</span></p>
	<p class="paragraph01">The file system abstraction has been a powerful idea, most recently applied to network resources in the form of the World Wide Web. Even so, there are other models for operating system interfaces. Multics, a predecessor of Unix, abstracted file storage in a way that made it look like memory, producing a very different flavor of interface. The complexity of the Multics design had a direct influence on the designers of Unix, who tried to build something simpler.</p>
	<p class="block_76">This book examines how xv6 implements its Unix-like interface, but the ideas and concepts apply to more than just Unix. Any operating system must multiplex processes onto the underlying hardware, isolate processes from each other, and provide mechanisms for controlled inter-process communication. After studying xv6, you should be able to look at other, more complex operating systems and see the concepts underlying xv6 in those systems as well.</p>
	<p class="block_77">Chapter 1</p>
	<h1 id="id_Toc460887575" class="block_13">Operating system organization</h1>
	<p class="paragraph01"><span class="text_2">A key requirement for an operating system is to support several activities. For example, using the system call interface described in chapter 0 a process can start new processes using </span><span class="text_3">fork</span><span class="text_2">. The operating system must arrange that these processes can </span><span class="text_3">time-share </span><span class="text_2">the resources of the computer. For example, a process may start more new processes than there are processors in the computer, yet all processes must be able to make some progress. In addition, the operating system must arrange for </span><span class="text_3">isolation </span><span class="text_2">between the processes. That is, if one process has a bug and fails, it shouldn’t impact processes that don’t have a dependency on the failed process. Complete isolation, however, is too strong, since it should be possible for processes to interact; for example, it is convenient for users to combine processes to perform complex tasks (e.g., by using pipes). Thus, the implementation of an operating system must achieve three requirements: multiplexing, isolation, and interaction.</span></p>
	<p class="paragraph01"><span class="text_2">This chapter provides an overview of how operating systems are organized to achieve these 3 requirements. It turns out there are many ways to do so, but this text focuses on mainstream designs centered around a </span><span class="text_3">monolithic kernel</span><span class="text_2">, which is used by many Unix operating systems. This chapter illustrates this organization by tracing the first process that is created when xv6 starts running. In doing so, the text provides a glimpse of the implementation of all major abstractions that xv6 provides, how they interact, and how the three requirements of multiplexing, isolation, and interaction are met. Most of xv6 avoids special-casing the first process, and instead reuses code that xv6 must provide for standard operation. Subsequent chapters will explore each abstraction in more detail.</span></p>
	<p class="block_78">Xv6 runs on Intel 80386 or later (‘‘x86’’) processors on a PC platform, and much of its low-level functionality (for example, its process implementation) is x86-specific. This book assumes the reader has done a bit of machine-level programming on some architecture, and will introduce x86-specific ideas as they come up. Appendix A briefly outlines the PC platform.</p>
	<h3 class="block_17">Abstracting physical resources</h3>
	<p class="paragraph01">The first question one might ask when encountering an operating system is why have it at all? That is, one could implement the system calls in Figure 0-2 as a library, with which applications link. In this plan, each application could even have its own library, perhaps tailored to its needs. In this plan, the application can directly interact with the hardware resources and use those resources in the best way for the application (e.g., to achieve high performance or predictable performance). Some tiny operating systems for embedded devices or real-time systems are organized in this way.</p>
	<p class="paragraph01">The downside of this approach is that applications are free to use the library, which means they can also <i class="calibre3">not </i>use it. If they don’t use the operating system library, then the operating system cannot enforce time sharing. It must rely on the application to behave properly and, for example, periodically give up a processor so that another application can run. Such a <i class="calibre3">cooperative </i>time-sharing scheme is maybe OK for a system where all applications trust each other, but doesn’t provide strong isolation if applications are mutually distrustful.</p>
	<p class="paragraph01"><span class="text_2">To achieve strong isolation a helpful approach is to disallow applications to have direct access to the hardware resources, but instead to abstract the resources into services. For example, applications interact with a file system only through </span><span class="text_3">open</span><span class="text_2">, </span><span class="text_3">read</span><span class="text_2">, </span><span class="text_3">write</span><span class="text_2">, and </span><span class="text_3">close </span><span class="text_2">system calls, instead of read and writing raw disk sectors. This provides the application with the convenience of pathnames, and it allows the operating system (as the implementor of the interface) to manage the disk.</span></p>
	<p class="paragraph01"><span class="text_2">Similarly, in Unix applications run as processes using </span><span class="text_3">fork</span><span class="text_2">, allowing the operating system to save and restore registers on behalf of the application when switching between different processes, so that application don’t have to be aware of process switching. Furthermore, it allows the operating system to forcefully switch an application out of a processor, if the application, for example, is an end-less loop.</span></p>
	<p class="paragraph01"><span class="text_2">As another example, Unix processes use </span><span class="text_3">exec </span><span class="text_2">to build up their memory image, instead of directly interacting with physical memory. This allows the operating system to decide where to place a process in memory and move things around if there is a shortage of memory, and provides applications with the convenience of a file system to store their images.</span></p>
	<p class="paragraph01">To support controled interaction between applications, Unix applications can use only file descriptors, instead of to make up some sharing convention of their own (e.g., reserving a piece of physical memory). Unix file descriptors abstract all the sharing details away, hiding from the application if the interaction is happening with the terminal, file system, or pipes, yet allows the operating system to control the interaction. For example, if one application fails, it can shut down the communication channel.</p>
	<p class="block_78">As you can see, the system call interface in Figure 0-2 is carefully designed to provide programmer convenience but also for the implementation of the interface to enforce strong isolation. The Unix interface is not the only way to abstract resources, but it has proven to be a very good one.</p>
	<h3 class="block_17">User mode, kernel mode, and system calls</h3>
	<p class="paragraph01">To provide strong isolation between the software that uses system calls and the software that implements the system calls, we need a hard boundary between applications and the operating system. If the application makes a mistake, we don’t want the operating system to fail. Instead, the operating system should be able to clean up the application and continue running other applications. This strong isolation means that application shouldn’t be able to write over data structures maintained by the operating system, shouldn’t be able to overwrite instructions of the operating system, etc.</p>
	<p class="block_79"><span class="text_2">To provide for such strong isolation processors provide hardware support. <span class="tab">       </span>For example, the x86 processor, like many other processors, has two modes in which the processor executes instructions: </span><span class="text_3">kernel mode </span><span class="text_2">and </span><span class="text_3">user mode</span><span class="text_2">. In kernel mode the processor is allowed to execute </span><span class="text_3">privileged instructions</span><span class="text_2">. For example, read and writing to the disk (or any other I/O device) is a privileged instruction. If an application in user mode attempts to execute a privileged instruction, then the processor doesn’t execute the instruction, but switches to kernel mode so that the software in kernel mode can clean up the application, because it did something it shouldn’t be doing. Figure 0-1 in Chapter 0 illustrates this organization. Applications can execute only usermode instructions (e.g., adding numbers, etc.) and is said to be running in </span><span class="text_3">user space</span><span class="text_2">, while the software in kernel mode can execute also privileged instructions and is said to be running in </span><span class="text_3">kernel space</span><span class="text_2">. The software running in kernel space (or in kernel mode) is called the </span><span class="text_3">kernel</span><span class="text_2">.</span></p>
	<p class="block_80"><span class="text_2">If a user-mode application must read or write to disk, it must transition to the kernel to do so, because the application itself can not execute I/O instructions. Processors provide a special instruction that switches the processor from user mode to kernel mode and enters the kernel at an entry point specified by the kernel. (The x86 processor provides the </span><span class="text_3">int </span><span class="text_2">instruction for this purpose.) Once the processor has switched to kernel mode, the kernel can then validate the arguments of the system call, decide whether the application is allowed to perform the requested operation, and then deny it or execute it. It is important that the kernel sets the entry point when transition to kernel mode; if the application could decide the kernel entry point, a malicious application could enter the kernel at a point where the validation of arguments etc. is skipped.</span></p>
	<h3 class="block_17">Kernel organization</h3>
	<p class="paragraph01"><span class="text_2">A key design question for an operating system is what part of the operating system should run in kernel mode. A simple answer is that the kernel interface is the system call interface. That is, </span><span class="text_3">fork</span><span class="text_2">, </span><span class="text_3">exec</span><span class="text_2">, </span><span class="text_3">open</span><span class="text_2">, </span><span class="text_3">close</span><span class="text_2">, </span><span class="text_3">read</span><span class="text_2">, </span><span class="text_3">write</span><span class="text_2">, etc. are all kernel calls. This choice means that the complete implementation of the operating system runs in kernel mode. This kernel organization is called a </span><span class="text_3">monolithic kernel</span><span class="text_2">.</span></p>
	<p class="paragraph01">In this organization the complete operating system runs with full hardware privilege. This organization is convenient because the OS designer doesn’t have to decide which part of the operating system doesn’t need full hardware privilege. Furthermore, it easy for different parts of the operating system to cooperate. For example, an operating system might have a buffer cache that can be shared both by the file system and the virtual memory system.</p>
	<p class="paragraph01">A downside of the monolithic organization is that the interfaces between different parts of the operating system are often complex (as we will see in the rest of this text), and therefore it is easy for an operating system developer to make a mistake. In a monolithic kernel, a mistake is fatal, because an error in kernel mode will often result in the kernel to fail. If the kernel fails, the computer stops working, and thus all applications fail too. The computer must reboot to start again.</p>
	<p class="block_81"><span class="text_2">To reduce the risk of mistakes in the kernel, OS designers can make the lines of code that run in kernel mode small. Most of the operating system doesn’t need access to privileged instructions, and can thus run as ordinary user-level applications, with which applications interact with through messages. This kernel organization is called a </span><span class="text_3">microkernel</span><span class="text_2">.</span></p>
	<p class="paragraph01">Figure 1-1 illustrates this microkernel design. In the figure, the file system runs as a user-level application. Operating systems that services that run as ordinary user programs are called servers. To allow application to interact with the file server, the kernel provides a minimal mechanism to send messages from one user-mode application to another. For example, if an application like the shell wants to read or write a file, it sends a message to the file server and waits for a response.</p>
	<p class="paragraph01">In a microkernel, the kernel interface consists of a few low-level functions for starting applications, performing I/O, sending messages to applications, etc. This organization allows the kernel to be implemented with a few lines of code, since it doesn’t do much, as most functionality of the operating system is implemented by user-level servers.</p>
	<p class="block_82"><span class="text_5"></span><span class="text_4">In the real-world, one can find both monolithic kernels and microkernels. For example, Linux is mostly implemented as a monolithic kernel, although some OS functions run as user-level servers (e.g., the windowing system). Xv6 is implemented as a monolithic kernel, following most Unix operating systems. Thus, in xv6, the kernel interface corresponds to the operating system interface, and the kernel implements the complete operating system. Since xv6 doesn’t provide many functions, its kernel is smaller than some microkernels.</span></p>
	<p class="block_19">Microkernel</p>
	<p class="block_19">shell</p>
	<p class="block_19">File<span class="text_16"> </span>server</p>
	<p class="block_19">user</p>
	<p class="block_19">space</p>
	<p class="block_19">kernel</p>
	<p class="block_19">space</p>
	<p class="block_19">Send<span class="text_17"> </span>message</p>
	<p class="block_20"><b class="calibre2">Figure</b><span class="text_9"> </span><b class="calibre2">1-1</b></p>
	<p class="block_20">.<span class="text_10"> </span>A<span class="text_11"> </span>mkernel<span class="text_11"> </span>with<span class="text_11"> </span>a</p>
	<p class="block_20">file<span class="text_11"> </span>system<span class="text_11"> </span>server</p>
	<p class="block_19">Microkernel</p>
	<p class="block_19">shell</p>
	<p class="block_19">File<span class="text_16"> </span>server</p>
	<p class="block_19">user</p>
	<p class="block_19">space</p>
	<p class="block_19">kernel</p>
	<p class="block_19">space</p>
	<p class="block_19">Send<span class="text_17"> </span>message</p>
	<p class="block_20"><b class="calibre2">Figure</b><span class="text_9"> </span><b class="calibre2">1-1</b></p>
	<p class="block_20">.<span class="text_10"> </span>A<span class="text_11"> </span>mkernel<span class="text_11"> </span>with<span class="text_11"> </span>a</p>
	<p class="block_20">file<span class="text_11"> </span>system<span class="text_11"> </span>server</p>
	<h3 class="block_56">Process overview</h3>
	<p class="paragraph01"><span class="text_2">The unit of isolation in xv6 (as in other Unix operating systems) is a </span><span class="text_3">process</span><span class="text_2">. The process abstraction prevents one process from wrecking or spying on another process’ memory, CPU, file descriptors, etc. It also prevents a process from wrecking the kernel itself (i.e., from preventing the kernel to enforce isolation). The kernel must implement the process abstraction with care because a buggy or malicious application may trick the kernel or hardware in doing something bad (e.g., circumventing enforced isolation). The mechanisms used by the kernel to implement processes include user/kernel mode flag, address spaces, and time slicing of threads, which this subsection provides an overview of.</span></p>
	<p class="paragraph01"><span class="text_2">To be able to enforce isolation, a process is an abstraction that provides the illusion to a program that it has its own abstract machine. A process provides a program with what appears to be a private memory system, or </span><span class="text_3">address space</span><span class="text_2">, which other processes cannot read or write. A process also provides the program with what appears to be its own CPU to execute the program’s instructions.</span></p>
	<p class="block_83"><span class="text_2">Xv6 uses page tables (which are implemented by hardware) to give each process its own address space. The x86 page table translates (or ‘‘maps’’) a </span><span class="text_3">virtual address </span><span class="text_2">(the address that an x86 instruction manipulates) to a </span><span class="text_3">physical address </span><span class="text_2">(an address that the processor chip sends to main memory).</span></p>
	<p class="paragraph01"><span class="text_2">Xv6 maintains a separate page table for each process that defines that process’s address space. As illustrated in Figure 1-2, an address space includes the process’s </span><span class="text_3">user memory </span><span class="text_2">starting at virtual address zero. Instructions come first, followed by global variables, then the stack, and finally a ‘‘heap’’ area (for malloc) that the process can expand as needed.</span></p>
	<p class="paragraph01"><span class="text_6"></span><span class="text_7">Each process’s address space maps the kernel’s instructions and data as well as the user program’s memory. When a process invokes a system call, the system call executes in the kernel mappings of the process’s address space. This arrangement exists so that the kernel’s system call code can directly refer to user memory. In order to leave room for user memory to grow, xv6’s address spaces map the kernel at high addresses, starting at </span><span class="text_8">0x80100000</span><span class="text_7">.</span></p>
	<p class="block_19">0</p>
	<p class="block_19">0x80000000</p>
	<p class="block_19">0</p>
	<p class="block_19">xFFFFFFFF</p>
	<p class="block_19">0x80100000</p>
	<p class="block_19">text<span class="text_16"> </span>and<span class="text_16"> </span>data</p>
	<p class="block_19">free<span class="text_18"> </span>memory</p>
	<p class="block_19">BIOS</p>
	<p class="block_19">user<span class="text_16"> </span>text</p>
	<p class="block_19">and<span class="text_16"> </span>data</p>
	<p class="block_19">user<span class="text_16"> </span>stack</p>
	<p class="block_19">heap</p>
	<p class="block_19">kernel</p>
	<p class="block_19">user</p>
	<p class="block_20"><b class="calibre2">Figure</b><span class="text_9"> </span><b class="calibre2">1-2</b></p>
	<p class="block_20">.<span class="text_19"> </span>Layout<span class="text_11"> </span>of<span class="text_20"> </span>a<span class="text_11"> </span>virtual<span class="text_11"> </span>address<span class="text_11"> </span>space</p>
	<p class="block_19">0</p>
	<p class="block_19">0x80000000</p>
	<p class="block_19">0</p>
	<p class="block_19">xFFFFFFFF</p>
	<p class="block_19">0x80100000</p>
	<p class="block_19">text<span class="text_16"> </span>and<span class="text_16"> </span>data</p>
	<p class="block_19">free<span class="text_18"> </span>memory</p>
	<p class="block_19">BIOS</p>
	<p class="block_19">user<span class="text_16"> </span>text</p>
	<p class="block_19">and<span class="text_16"> </span>data</p>
	<p class="block_19">user<span class="text_16"> </span>stack</p>
	<p class="block_19">heap</p>
	<p class="block_19">kernel</p>
	<p class="block_19">user</p>
	<p class="block_20"><b class="calibre2">Figure</b><span class="text_9"> </span><b class="calibre2">1-2</b></p>
	<p class="block_20">.<span class="text_19"> </span>Layout<span class="text_11"> </span>of<span class="text_20"> </span>a<span class="text_11"> </span>virtual<span class="text_11"> </span>address<span class="text_11"> </span>space</p>
	<p class="paragraph01"><span class="text_7">The xv6 kernel maintains many pieces of state for each process, which it gathers into a </span><span class="text_8">struct proc </span><span class="text_6">(2353)</span><span class="text_7">. A process’s most important pieces of kernel state are its page table, its kernel stack, and its run state. We’ll use the notation </span><span class="text_8">p-&gt;xxx </span><span class="text_7">to refer to elements of the </span><span class="text_8">proc </span><span class="text_7">structure.</span></p>
	<p class="paragraph01"><span class="text_2">Each process has a thread of execution (or </span><span class="text_3">thread </span><span class="text_2">for short) that executes the process’s instructions. A thread can be suspended and later resumed. To switch transparently between processes, the kernel suspends the currently running thread and resumes another process’s thread. Much of the state of a thread (local variables, function call return addresses) is stored on the thread’s stacks. Each process has two stacks: a user stack and a kernel stack (</span><span class="text_3">p-&gt;kstack</span><span class="text_2">). When the process is executing user instructions, only its user stack is in use, and its kernel stack is empty. When the process enters the kernel (for a system call or interrupt), the kernel code executes on the process’s kernel stack; while a process is in the kernel, its user stack still contains saved data, but isn’t actively used. A process’s thread alternates between actively using its user stack and its kernel stack. The kernel stack is separate (and protected from user code) so that the kernel can execute even if a process has wrecked its user stack.</span></p>
	<p class="paragraph01">When a process makes a system call, the processor switches to the kernel stack, raises the hardware privilege level, and starts executing the kernel instructions that implement the system call. When the system call completes, the kernel returns to user space: the hardware lowers its privilege level, switches back to the user stack, and resumes executing user instructions just after the system call instruction. A process’s thread can ‘‘block’’ in the kernel to wait for I/O, and resume where it left off when the I/O has finished.</p>
	<p class="block_79"><span class="text_3">p-&gt;state </span><span class="text_2">indicates whether the process is allocated, ready to run, running, wait-</span></p>
	<p class="block_11">ing for I/O, or exiting.</p>
	<p class="block_79"><span class="text_3">p-&gt;pgdir </span><span class="text_2">holds the process’s page table, in the format that the x86 hardware ex-</span></p>
	<p class="block_63"><span class="text_2">pects. xv6 causes the paging hardware to use a process’s </span><span class="text_3">p-&gt;pgdir </span><span class="text_2">when executing that process. A process’s page table also serves as the record of the addresses of the physical pages allocated to store the process’s memory.</span></p>
	<h3 class="block_17">Code: the first address space</h3>
	<p class="block_11">To make the xv6 organization more concrete, we look how the kernel creates the first address space (for itself), how the kernel creates and starts the first process, and the first system call that that process makes. By tracing these operations we see in detail how xv6 provides strong isolation for processes. The first step in providing strong isolation is setting up the kernel to run in its own address space.</p>
	<p class="paragraph01"><span class="text_7">When a PC powers on, it initializes itself and then loads a </span><span class="text_8">boot loader </span><span class="text_7">from disk into memory and executes it. Appendix B explains the details. Xv6’s boot loader loads the xv6 kernel from disk and executes it starting at </span><span class="text_8">entry </span><span class="text_6">(1040)</span><span class="text_7">. The x86 paging hardware is not enabled when the kernel starts; virtual addresses map directly to physical addresses.</span></p>
	<p class="paragraph01"><span class="text_2">The boot loader loads the xv6 kernel into memory at physical address </span><span class="text_3">0x100000</span><span class="text_2">. The reason it doesn’t load the kernel at </span><span class="text_3">0x80100000</span><span class="text_2">, where the kernel expects to find its instructions and data, is that there may not be any physical memory at such a high address on a small machine. The reason it places the kernel at </span><span class="text_3">0x100000 </span><span class="text_2">rather than </span><span class="text_3">0x0 </span><span class="text_2">is because the address range </span><span class="text_3">0xa0000:0x100000 </span><span class="text_2">contains I/O devices.</span></p>
	<p class="paragraph01"><span class="text_7">To allow the rest of the kernel to run, </span><span class="text_8">entry </span><span class="text_7">sets up a page table that maps virtual addresses starting at </span><span class="text_8">0x80000000 </span><span class="text_7">(called </span><span class="text_8">KERNBASE </span><span class="text_6">(0207)</span><span class="text_7">) to physical addresses starting at </span><span class="text_8">0x0 </span><span class="text_7">(see Figure 1-2). Setting up two ranges of virtual addresses that map to the same physical memory range is a common use of page tables, and we will see more examples like this one.</span></p>
	<p class="block_42"><span class="text_4">The entry page table is defined in main.c </span><span class="text_5">(1311)</span><span class="text_4">. We look at the details of page tables in Chapter 2, but the short story is that entry 0 maps virtual addresses</span></p>
	<p class="block_84"><span class="text_12"></span><span class="text_12">Virtual address space</span></p>
	<p class="block_19">0</p>
	<p class="block_19">0x80000000</p>
	<p class="block_19">0</p>
	<p class="block_19">xFFFFFFFF</p>
	<p class="block_19">0x80100000</p>
	<p class="block_19">text<span class="text_16"> </span>and<span class="text_16"> </span>data</p>
	<p class="block_19">BIOS</p>
	<p class="block_19">Physical<span class="text_16"> </span>memory</p>
	<p class="block_19">Top<span class="text_16"> </span>physical</p>
	<p class="block_19">memory</p>
	<p class="block_19">kernel<span class="text_16"> </span>text</p>
	<p class="block_19">and<span class="text_16"> </span>data</p>
	<p class="block_19">4</p>
	<p class="block_19"><span class="text_16"> </span>Mbyte</p>
	<p class="block_19">0</p>
	<p class="block_19">BIOS</p>
	<p class="block_19">text<span class="text_16"> </span>and<span class="text_16"> </span>data</p>
	<p class="block_19">0</p>
	<p class="block_19">0x80000000</p>
	<p class="block_19">0</p>
	<p class="block_19">xFFFFFFFF</p>
	<p class="block_19">0x80100000</p>
	<p class="block_19">text<span class="text_16"> </span>and<span class="text_16"> </span>data</p>
	<p class="block_19">BIOS</p>
	<p class="block_19">Physical<span class="text_16"> </span>memory</p>
	<p class="block_19">Top<span class="text_16"> </span>physical</p>
	<p class="block_19">memory</p>
	<p class="block_19">kernel<span class="text_16"> </span>text</p>
	<p class="block_19">and<span class="text_16"> </span>data</p>
	<p class="block_19">4</p>
	<p class="block_19"><span class="text_16"> </span>Mbyte</p>
	<p class="block_19">0</p>
	<p class="block_19">BIOS</p>
	<p class="block_19">text<span class="text_16"> </span>and<span class="text_16"> </span>data</p>
	<p class="block_33"><b class="calibre2">Figure 1-3</b>. Layout of a virtual address space</p>
	<p class="block_85"><span class="text_3">0:0x400000 </span><span class="text_2">to physical addresses </span><span class="text_3">0:0x400000</span><span class="text_2">. This mapping is required as long as </span><span class="text_3">entry </span><span class="text_2">is executing at low addresses, but will eventually be removed.</span></p>
	<p class="paragraph01"><span class="text_2">Entry 512 maps virtual addresses </span><span class="text_3">KERNBASE:KERNBASE+0x400000 </span><span class="text_2">to physical addresses </span><span class="text_3">0:0x400000</span><span class="text_2">. This entry will be used by the kernel after </span><span class="text_3">entry </span><span class="text_2">has finished; it maps the high virtual addresses at which the kernel expects to find its instructions and data to the low physical addresses where the boot loader loaded them. This mapping restricts the kernel instructions and data to 4 Mbytes.</span></p>
	<p class="paragraph01"><span class="text_6"></span><span class="text_7">Returning to </span><span class="text_8">entry, </span><span class="text_7">it loads the physical address of </span><span class="text_8">entrypgdir </span><span class="text_7">into control register </span><span class="text_8">%cr3. </span><span class="text_7">The paging hardware must know the physical address of </span><span class="text_8">entrypgdir, </span><span class="text_7">because it doesn’t know how to translate virtual addresses yet; it doesn’t have a page table yet. The symbol </span><span class="text_8">entrypgdir </span><span class="text_7">refers to an address in high memory, and the macro </span><span class="text_8">V2P_WO </span><span class="text_6">(0220) </span><span class="text_7">subtracts </span><span class="text_8">KERNBASE </span><span class="text_7">in order to find the physical address. To enable the paging hardware, xv6 sets the flag </span><span class="text_8">CR0_PG </span><span class="text_7">in the control register </span><span class="text_8">%cr0.</span></p>
	<p class="paragraph01"><span class="text_2">The processor is still executing instructions at low addresses after paging is enabled, which works since </span><span class="text_3">entrypgdir </span><span class="text_2">maps low addresses. If xv6 had omitted entry 0 from </span><span class="text_3">entrypgdir, </span><span class="text_2">the computer would have crashed when trying to execute the instruction after the one that enabled paging.</span></p>
	<p class="paragraph01"><span class="text_7">Now </span><span class="text_8">entry </span><span class="text_7">needs to transfer to the kernel’s C code, and run it in high memory. First it makes the stack pointer, </span><span class="text_8">%esp</span><span class="text_7">, point to memory to be used as a stack </span><span class="text_6">(1054)</span><span class="text_7">. All symbols have high addresses, including </span><span class="text_8">stack</span><span class="text_7">, so the stack will still be valid even when the low mappings are removed. Finally </span><span class="text_8">entry </span><span class="text_7">jumps to </span><span class="text_8">main</span><span class="text_7">, which is also a high address. The indirect jump is needed because the assembler would otherwise generate a PC-relative direct jump, which would execute the low-memory version of </span><span class="text_8">main</span><span class="text_7">. Main cannot return, since the there’s no return PC on the stack. Now the kernel is running in high addresses in the function </span><span class="text_8">main </span><span class="text_6">(1217)</span><span class="text_7">.</span></p>
	<h3 class="block_17">Code: creating the first process</h3>
	<p class="paragraph01">Now the kernel runs within its own address space, we look at how the kernel creates user-level processes and ensures strong isolation between the kernel and user-level processes, and between processes themselves.</p>
	<p class="paragraph01"><span class="text_7">After </span><span class="text_8">main </span><span class="text_7">initializes several devices and subsystems, it creates the first process by calling </span><span class="text_8">userinit </span><span class="text_6">(1239)</span><span class="text_7">. </span><span class="text_8">Userinit</span><span class="text_7">’s first action is to call </span><span class="text_8">allocproc</span><span class="text_7">. The job of </span><span class="text_8">allocproc </span><span class="text_6">(2455) </span><span class="text_7">is to allocate a slot (a </span><span class="text_8">struct proc</span><span class="text_7">) in the process table and to initialize the parts of the process’s state required for its kernel thread to execute. </span><span class="text_8">Allocproc </span><span class="text_7">is called for each new process, while </span><span class="text_8">userinit </span><span class="text_7">is called only for the very first process.</span></p>
	<p class="block_86"><span class="text_6"></span><span class="text_8">Allocproc </span><span class="text_7">scans the </span><span class="text_8">proc </span><span class="text_7">table for a slot with state </span><span class="text_8">UNUSED </span><span class="text_6">(2461-2463)</span><span class="text_7">. When it finds an unused slot, </span><span class="text_8">allocproc </span><span class="text_7">sets the state to </span><span class="text_8">EMBRYO </span><span class="text_7">to mark it as used and gives the process a unique </span><span class="text_8">pid </span><span class="text_6">(2451-2469)</span><span class="text_7">. Next, it tries to allocate a kernel stack for the process’s kernel thread. If the memory allocation fails, </span><span class="text_8">allocproc </span><span class="text_7">changes the state back to </span><span class="text_8">UNUSED </span><span class="text_7">and returns zero to signal failure.</span></p>
	<p class="block_19">p-&gt;kstack</p>
	<p class="block_19">p-&gt;context</p>
	<p class="block_19">p-&gt;tf</p>
	<p class="block_19">esp</p>
	<p class="block_19">eip</p>
	<p class="block_19">edi</p>
	<p class="block_19">trapret</p>
	<p class="block_19">eip</p>
	<p class="block_19">...</p>
	<p class="block_19">edi</p>
	<p class="block_19">empty</p>
	<p class="block_19">)</p>
	<p class="block_19">(</p>
	<p class="block_19">...</p>
	<p class="block_19">...</p>
	<p class="block_19">top<span class="text_21"> </span>of<span class="text_21"> </span>new<span class="text_21"> </span>stack</p>
	<p class="block_19">address<span class="text_22"> </span>forkret<span class="text_21"> </span>will<span class="text_21"> </span>return<span class="text_21"> </span>to</p>
	<p class="block_20"><b class="calibre2">Figure</b><span class="text_9"> </span><b class="calibre2">1-4</b></p>
	<p class="block_20">.<span class="text_10"> </span>A<span class="text_11"> </span>new<span class="text_11"> </span>kernel<span class="text_11"> </span>stack.</p>
	<p class="block_19">p-&gt;kstack</p>
	<p class="block_19">p-&gt;context</p>
	<p class="block_19">p-&gt;tf</p>
	<p class="block_19">esp</p>
	<p class="block_19">eip</p>
	<p class="block_19">edi</p>
	<p class="block_19">trapret</p>
	<p class="block_19">eip</p>
	<p class="block_19">...</p>
	<p class="block_19">edi</p>
	<p class="block_19">empty</p>
	<p class="block_19">)</p>
	<p class="block_19">(</p>
	<p class="block_19">...</p>
	<p class="block_19">...</p>
	<p class="block_19">top<span class="text_21"> </span>of<span class="text_21"> </span>new<span class="text_21"> </span>stack</p>
	<p class="block_19">address<span class="text_22"> </span>forkret<span class="text_21"> </span>will<span class="text_21"> </span>return<span class="text_21"> </span>to</p>
	<p class="block_20"><b class="calibre2">Figure</b><span class="text_9"> </span><b class="calibre2">1-4</b></p>
	<p class="block_20">.<span class="text_10"> </span>A<span class="text_11"> </span>new<span class="text_11"> </span>kernel<span class="text_11"> </span>stack.</p>
	<p class="paragraph01"><span class="text_7">Now </span><span class="text_8">allocproc </span><span class="text_7">must set up the new process’s kernel stack. </span><span class="text_8">allocproc </span><span class="text_7">is written so that it can be used by </span><span class="text_8">fork </span><span class="text_7">as well as when creating the first process. </span><span class="text_8">allocproc </span><span class="text_7">sets up the new process with a specially prepared kernel stack and set of kernel registers that cause it to ‘‘return’’ to user space when it first runs. The layout of the prepared kernel stack will be as shown in Figure 1-4. </span><span class="text_8">allocproc </span><span class="text_7">does part of this work by setting up return program counter values that will cause the new process’s kernel thread to first execute in </span><span class="text_8">forkret </span><span class="text_7">and then in </span><span class="text_8">trapret </span><span class="text_6">(2486-2491)</span><span class="text_7">. The kernel thread will start executing with register contents copied from </span><span class="text_8">p-&gt;context</span><span class="text_7">. Thus setting </span><span class="text_8">p&gt;context-&gt;eip </span><span class="text_7">to </span><span class="text_8">forkret </span><span class="text_7">will cause the kernel thread to execute at the start of </span><span class="text_8">forkret </span><span class="text_6">(2783)</span><span class="text_7">. This function will return to whatever address is at the bottom of the stack. The context switch code </span><span class="text_6">(2958) </span><span class="text_7">sets the stack pointer to point just beyond the end of </span><span class="text_8">p-&gt;context</span><span class="text_7">. </span><span class="text_8">allocproc </span><span class="text_7">places </span><span class="text_8">p-&gt;context </span><span class="text_7">on the stack, and puts a pointer to </span><span class="text_8">trapret </span><span class="text_7">just above it; that is where </span><span class="text_8">forkret </span><span class="text_7">will return. </span><span class="text_8">trapret </span><span class="text_7">restores user registers from values stored at the top of the kernel stack and jumps into the process </span><span class="text_6">(3277)</span><span class="text_7">. This setup is the same for ordinary </span><span class="text_8">fork </span><span class="text_7">and for creating the first process, though in the latter case the process will start executing at user-space location zero rather than at a return from </span><span class="text_8">fork</span><span class="text_7">.</span></p>
	<p class="paragraph01"><span class="text_7">As we will see in Chapter 3, the way that control transfers from user software to the kernel is via an interrupt mechanism, which is used by system calls, interrupts, and exceptions. Whenever control transfers into the kernel while a process is running, the hardware and xv6 trap entry code save user registers on the process’s kernel stack. </span><span class="text_8">userinit </span><span class="text_7">writes values at the top of the new stack that look just like those that would be there if the process had entered the kernel via an interrupt </span><span class="text_6">(2514-2520)</span><span class="text_7">, so that the ordinary code for returning from the kernel back to the process’s user code will work. These values are a </span><span class="text_8">struct trapframe </span><span class="text_7">which stores the user registers. Now the new process’s kernel stack is completely prepared as shown in Figure 1-4.</span></p>
	<p class="paragraph01"><span class="text_7">The first process is going to execute a small program (</span><span class="text_8">initcode.S</span><span class="text_7">; </span><span class="text_6">(8200)</span><span class="text_7">). The process needs physical memory in which to store this program, the program needs to be copied to that memory, and the process needs a page table that refers to that memory.</span></p>
	<p class="paragraph01"><span class="text_8">userinit </span><span class="text_7">calls </span><span class="text_8">setupkvm </span><span class="text_6">(1837) </span><span class="text_7">to create a page table for the process with (at first) mappings only for memory that the kernel uses. We will study this function in detail in Chapter 2, but at a high level </span><span class="text_8">setupkvm </span><span class="text_7">and </span><span class="text_8">userinit </span><span class="text_7">create an address space as shown Figure 1-2.</span></p>
	<p class="paragraph01"><span class="text_7">The initial contents of the first process’s memory are the compiled form of </span><span class="text_8">initcode.S</span><span class="text_7">; as part of the kernel build process, the linker embeds that binary in the kernel and defines two special symbols, </span><span class="text_8">_binary_initcode_start </span><span class="text_7">and </span><span class="text_8">_binary_initcode_size</span><span class="text_7">, indicating the location and size of the binary. </span><span class="text_8">Userinit </span><span class="text_7">copies that binary into the new process’s memory by calling </span><span class="text_8">inituvm</span><span class="text_7">, which allocates one page of physical memory, maps virtual address zero to that memory, and copies the binary to that page </span><span class="text_6">(1903)</span><span class="text_7">.</span></p>
	<p class="paragraph01"><span class="text_7">Then </span><span class="text_8">userinit </span><span class="text_7">sets up the trap frame </span><span class="text_6">(0602) </span><span class="text_7">with the initial user mode state: the </span><span class="text_8">%cs </span><span class="text_7">register contains a segment selector for the </span><span class="text_8">SEG_UCODE </span><span class="text_7">segment running at privilege level </span><span class="text_8">DPL_USER </span><span class="text_7">(i.e., user mode not kernel mode), and similarly </span><span class="text_8">%ds</span><span class="text_7">, </span><span class="text_8">%es</span><span class="text_7">, and </span><span class="text_8">%ss </span><span class="text_7">use </span><span class="text_8">SEG_UDATA </span><span class="text_7">with privilege </span><span class="text_8">DPL_USER</span><span class="text_7">. The </span><span class="text_8">%eflags FL_IF </span><span class="text_7">bit is set to allow hardware interrupts; we will reexamine this in Chapter 3.</span></p>
	<p class="paragraph01"><span class="text_2">The stack pointer </span><span class="text_3">%esp </span><span class="text_2">is set to the process’s largest valid virtual address, </span><span class="text_3">p-&gt;sz</span><span class="text_2">. The instruction pointer is set to the entry point for the initcode, address 0.</span></p>
	<p class="paragraph01"><span class="text_2">The function </span><span class="text_3">userinit </span><span class="text_2">sets </span><span class="text_3">p-&gt;name </span><span class="text_2">to </span><span class="text_3">initcode </span><span class="text_2">mainly for debugging. Setting </span><span class="text_3">p-&gt;cwd </span><span class="text_2">sets the process’s current working directory; we will examine </span><span class="text_3">namei </span><span class="text_2">in detail in Chapter 6.</span></p>
	<p class="block_87"><span class="text_2">Once the process is initialized, </span><span class="text_3">userinit </span><span class="text_2">marks it available for scheduling by setting </span><span class="text_3">p-&gt;state </span><span class="text_2">to </span><span class="text_3">RUNNABLE</span><span class="text_2">.</span></p>
	<h3 class="block_17">Code: Running the first process</h3>
	<p class="block_88"><span class="text_7">Now that the first process’s state is prepared, it is time to run it. After </span><span class="text_8">main </span><span class="text_7">calls </span><span class="text_8">userinit</span><span class="text_7">, </span><span class="text_8">mpmain </span><span class="text_7">calls </span><span class="text_8">scheduler </span><span class="text_7">to start running processes </span><span class="text_6">(1267)</span><span class="text_7">. </span><span class="text_8">Scheduler </span><span class="text_6">(2708) </span><span class="text_7">looks for a process with </span><span class="text_8">p-&gt;state </span><span class="text_7">set to </span><span class="text_8">RUNNABLE</span><span class="text_7">, and there’s only one: </span><span class="text_8">initproc</span><span class="text_7">. It sets the per-cpu variable </span><span class="text_8">proc </span><span class="text_7">to the process it found and calls </span><span class="text_8">switchuvm </span><span class="text_7">to tell the hardware to start using the target process’s page table </span><span class="text_6">(1868)</span><span class="text_7">. Changing page tables while executing in the kernel works because </span><span class="text_8">setupkvm </span><span class="text_7">causes all processes’ page tables to have identical mappings for kernel code and data. </span><span class="text_8">switchuvm </span><span class="text_7">also sets up a task state segment </span><span class="text_8">SEG_TSS </span><span class="text_7">that instructs the hardware to execute system calls and interrupts on the process’s kernel stack. We will re-examine the task state segment in Chapter 3.</span></p>
	<p class="paragraph01"><span class="text_8">scheduler </span><span class="text_7">now sets </span><span class="text_8">p-&gt;state </span><span class="text_7">to </span><span class="text_8">RUNNING </span><span class="text_7">and calls </span><span class="text_8">swtch </span><span class="text_6">(2958) </span><span class="text_7">to perform a context switch to the target process’s kernel thread. </span><span class="text_8">swtch </span><span class="text_7">saves the current registers and loads the saved registers of the target kernel thread (</span><span class="text_8">proc-&gt;context</span><span class="text_7">) into the x86 hardware registers, including the stack pointer and instruction pointer. The current context is not a process but rather a special per-cpu scheduler context, so </span><span class="text_8">scheduler </span><span class="text_7">tells </span><span class="text_8">swtch </span><span class="text_7">to save the current hardware registers in per-cpu storage (</span><span class="text_8">cpu-&gt;scheduler</span><span class="text_7">) rather than in any process’s kernel thread context. We’ll examine </span><span class="text_8">swtch </span><span class="text_7">in more detail in Chapter 5. The final </span><span class="text_8">ret </span><span class="text_7">instruction </span><span class="text_6">(2977) </span><span class="text_7">pops the target process’s </span><span class="text_8">%eip </span><span class="text_7">from the stack, finishing the context switch. Now the processor is running on the kernel stack of process </span><span class="text_8">p</span><span class="text_7">.</span></p>
	<p class="paragraph01"><span class="text_8">Allocproc </span><span class="text_7">set </span><span class="text_8">initproc</span><span class="text_7">’s </span><span class="text_8">p-&gt;context-&gt;eip </span><span class="text_7">to </span><span class="text_8">forkret</span><span class="text_7">, so the </span><span class="text_8">ret </span><span class="text_7">starts executing </span><span class="text_8">forkret</span><span class="text_7">. On the first invocation (that is this one), </span><span class="text_8">forkret </span><span class="text_6">(2783) </span><span class="text_7">runs initialization functions that cannot be run from </span><span class="text_8">main </span><span class="text_7">because they must be run in the context of a regular process with its own kernel stack. Then, </span><span class="text_8">forkret </span><span class="text_7">returns. </span><span class="text_8">Allocproc </span><span class="text_7">arranged that the top word on the stack after </span><span class="text_8">p-&gt;context </span><span class="text_7">is popped off would be </span><span class="text_8">trapret</span><span class="text_7">, so now </span><span class="text_8">trapret </span><span class="text_7">begins executing, with </span><span class="text_8">%esp </span><span class="text_7">set to </span><span class="text_8">p-&gt;tf</span><span class="text_7">. </span><span class="text_8">Trapret </span><span class="text_6">(3277) </span><span class="text_7">uses pop instructions to restore registers from the trap frame </span><span class="text_6">(0602) </span><span class="text_7">just as </span><span class="text_8">swtch </span><span class="text_7">did with the kernel context: </span><span class="text_8">popal </span><span class="text_7">restores the general registers, then the </span><span class="text_8">popl </span><span class="text_7">instructions restore </span><span class="text_8">%gs</span><span class="text_7">, </span><span class="text_8">%fs</span><span class="text_7">, </span><span class="text_8">%es</span><span class="text_7">, and </span><span class="text_8">%ds</span><span class="text_7">. The </span><span class="text_8">addl </span><span class="text_7">skips over the two fields </span><span class="text_8">trapno </span><span class="text_7">and </span><span class="text_8">errcode</span><span class="text_7">. Finally, the </span><span class="text_8">iret </span><span class="text_7">instruction pops </span><span class="text_8">%cs</span><span class="text_7">, </span><span class="text_8">%eip</span><span class="text_7">, </span><span class="text_8">%flags</span><span class="text_7">, </span><span class="text_8">%esp</span><span class="text_7">, and </span><span class="text_8">%ss </span><span class="text_7">from the stack. The contents of the trap frame have been transferred to the CPU state, so the processor continues at the </span><span class="text_8">%eip </span><span class="text_7">specified in the trap frame. For </span><span class="text_8">initproc</span><span class="text_7">, that means virtual address zero, the first instruction of </span><span class="text_8">initcode.S</span><span class="text_7">.</span></p>
	<p class="block_89"><span class="text_7">At this point, </span><span class="text_8">%eip </span><span class="text_7">holds zero and </span><span class="text_8">%esp </span><span class="text_7">holds 4096. These are virtual addresses in the process’s address space. The processor’s paging hardware translates them into physical addresses. </span><span class="text_8">allocuvm </span><span class="text_7">set up the process’s page table so that virtual address zero refers to the physical memory allocated for this process, and set a flag (</span><span class="text_8">PTE_U</span><span class="text_7">) that tells the paging hardware to allow user code to access that memory. The fact that </span><span class="text_8">userinit </span><span class="text_6">(2514) </span><span class="text_7">set up the low bits of </span><span class="text_8">%cs </span><span class="text_7">to run the process’s user code at CPL=3 means that the user code can only use pages with </span><span class="text_8">PTE_U </span><span class="text_7">set, and cannot modify sensitive hardware registers such as </span><span class="text_8">%cr3</span><span class="text_7">. So the process is constrained to using only its own memory.</span></p>
	<h3 class="block_17">The first system call: exec</h3>
	<p class="paragraph01">Now we have seen how the kernel provides strong isolation for processes, let’s see how a user-level process can enter back into the kernel to ask for services that it cannot perform itself.</p>
	<p class="paragraph01"><span class="text_2">The first action of </span><span class="text_3">initcode.S </span><span class="text_2">is to invoke the </span><span class="text_3">exec </span><span class="text_2">system call. As we saw in Chapter 0, </span><span class="text_3">exec </span><span class="text_2">replaces the memory and registers of the current process with a new program, but it leaves the file descriptors, process id, and parent process unchanged.</span></p>
	<p class="paragraph01"><span class="text_8">Initcode.S </span><span class="text_6">(8208) </span><span class="text_7">begins by pushing three values on the stack—</span><span class="text_8">$argv</span><span class="text_7">, </span><span class="text_8">$init</span><span class="text_7">, and </span><span class="text_8">$0</span><span class="text_7">—and then sets </span><span class="text_8">%eax </span><span class="text_7">to </span><span class="text_8">SYS_exec </span><span class="text_7">and executes </span><span class="text_8">int T_SYSCALL</span><span class="text_7">: it is asking the kernel to run the </span><span class="text_8">exec </span><span class="text_7">system call. If all goes well, </span><span class="text_8">exec </span><span class="text_7">never returns: it starts running the program named by </span><span class="text_8">$init</span><span class="text_7">, which is a pointer to the NUL-terminated string </span><span class="text_8">/init </span><span class="text_6">(8221-8223)</span><span class="text_7">. If the </span><span class="text_8">exec </span><span class="text_7">fails and does return, initcode loops calling the </span><span class="text_8">exit </span><span class="text_7">system call, which definitely should not return </span><span class="text_6">(8215-8219)</span><span class="text_7">.</span></p>
	<p class="paragraph01"><span class="text_2">The arguments to the </span><span class="text_3">exec </span><span class="text_2">system call are </span><span class="text_3">$init </span><span class="text_2">and </span><span class="text_3">$argv</span><span class="text_2">. The final zero makes this hand-written system call look like the ordinary system calls, as we will see in Chapter 3. As before, this setup avoids special-casing the first process (in this case, its first system call), and instead reuses code that xv6 must provide for standard operation.</span></p>
	<p class="block_89"><span class="text_7">Chapter 2 will cover the implementation of </span><span class="text_8">exec </span><span class="text_7">in detail, but at a high level it will replace </span><span class="text_8">initcode </span><span class="text_7">with the </span><span class="text_8">/init </span><span class="text_7">binary, loaded out of the file system. Now </span><span class="text_8">initcode </span><span class="text_6">(8200) </span><span class="text_7">is done, and the process will run </span><span class="text_8">/init </span><span class="text_7">instead. </span><span class="text_8">Init </span><span class="text_6">(8310) </span><span class="text_7">creates a new console device file if needed and then opens it as file descriptors 0, 1, and 2. Then it loops, starting a console shell, handles orphaned zombies until the shell exits, and repeats. The system is up.</span></p>
	<h3 class="block_17">Real world</h3>
	<p class="paragraph01"><span class="text_2">Most operating systems have adopted the process concept, and most processes look similar to xv6’s. A real operating system would find free </span><span class="text_3">proc </span><span class="text_2">structures with an explicit free list in constant time instead of the linear-time search in </span><span class="text_3">allocproc</span><span class="text_2">; xv6 uses the linear scan (the first of many) for simplicity.</span></p>
	<p class="block_55">xv6’s address space layout has the defect that it cannot make use of more than 2 GB of physical RAM. It’s possible to fix this, though the best plan would be to switch to a machine with 64-bit addresses.</p>
	<h3 class="block_90">Exercises</h3>
	<ol class="list_">
	<li class="block_91"><span class="text_2">Set a breakpoint at swtch. Single step with gdb’s </span><span class="text_3">stepi </span><span class="text_2">through the ret to </span><span class="text_3">forkret</span><span class="text_2">, then use gdb’s </span><span class="text_3">finish </span><span class="text_2">to proceed to </span><span class="text_3">trapret</span><span class="text_2">, then </span><span class="text_3">stepi </span><span class="text_2">until you get to </span><span class="text_3">initcode </span><span class="text_2">at virtual address zero.</span></li>
	<li class="block_92"><span class="text_3">KERNBASE </span><span class="text_2">limits the amount of memory a single process can use, which might be irritating on a machine with a full 4 GB of RAM. Would raising </span><span class="text_3">KERNBASE </span><span class="text_2">allow a process to use more memory?</span></li>
</ol>
	<p class="block_4"> </p>
	</body></html>
